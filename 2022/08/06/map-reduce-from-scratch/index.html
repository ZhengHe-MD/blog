<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zhenghe-md.github.io","root":"/blog/","images":"/blog/images","scheme":"Mist","darkmode":false,"version":"8.9.0","exturl":false,"sidebar":{"position":"left","display":"remove","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/blog/js/config.js"></script>
<meta name="description" content="在最近的工作中，为了做数据分析，我开始写一些复杂的 HiveSQL。每次执行 HiveSQL 时，都会看到 Map&#x2F;Reduce jobs 被调度、执行，直到最后展示出数据。渐渐地我心中多了两个疑问：  MapReduce 引擎如何工作？ SQL 是如何被翻译成 MapReduce job 的？  为了解决这两个疑问，我用比较熟悉的 Go 语言实现了一个玩具版本的 MapReduce 引擎，然后基">
<meta property="og:type" content="article">
<meta property="og:title" content="从 MapReduce 到 SQL">
<meta property="og:url" content="https://zhenghe-md.github.io/blog/2022/08/06/map-reduce-from-scratch/index.html">
<meta property="og:site_name" content="ZhengHe">
<meta property="og:description" content="在最近的工作中，为了做数据分析，我开始写一些复杂的 HiveSQL。每次执行 HiveSQL 时，都会看到 Map&#x2F;Reduce jobs 被调度、执行，直到最后展示出数据。渐渐地我心中多了两个疑问：  MapReduce 引擎如何工作？ SQL 是如何被翻译成 MapReduce job 的？  为了解决这两个疑问，我用比较熟悉的 Go 语言实现了一个玩具版本的 MapReduce 引擎，然后基">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zhenghe-md.github.io/blog/2022/08/06/map-reduce-from-scratch/map-reduce-word-count.png">
<meta property="og:image" content="https://zhenghe-md.github.io/blog/2022/08/06/map-reduce-from-scratch/map-reduce-entities.png">
<meta property="og:image" content="https://zhenghe-md.github.io/blog/2022/08/06/map-reduce-from-scratch/map-reduce-files.png">
<meta property="og:image" content="https://zhenghe-md.github.io/blog/2022/08/06/map-reduce-from-scratch/map-reduce-select.png">
<meta property="og:image" content="https://zhenghe-md.github.io/blog/2022/08/06/map-reduce-from-scratch/map-reduce-join.png">
<meta property="article:published_time" content="2022-08-06T22:16:08.000Z">
<meta property="article:modified_time" content="2023-01-06T13:51:11.564Z">
<meta property="article:author" content="ZhengHe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhenghe-md.github.io/blog/2022/08/06/map-reduce-from-scratch/map-reduce-word-count.png">


<link rel="canonical" href="https://zhenghe-md.github.io/blog/2022/08/06/map-reduce-from-scratch/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://zhenghe-md.github.io/blog/2022/08/06/map-reduce-from-scratch/","path":"2022/08/06/map-reduce-from-scratch/","title":"从 MapReduce 到 SQL"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>从 MapReduce 到 SQL | ZhengHe</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-172943223-1"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-172943223-1","only_pageview":false}</script>
  <script src="/blog/js/third-party/analytics/google-analytics.js"></script>





  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
<style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"] > svg a {
  fill: blue;
  stroke: blue;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container {
  overflow: auto hidden;
}

mjx-container + br {
  display: none;
}
</style><link rel="alternate" href="/blog/atom.xml" title="ZhengHe" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">ZhengHe</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-categories"><a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-about"><a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/ZhengHe-MD" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhenghe-md.github.io/blog/2022/08/06/map-reduce-from-scratch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="ZhengHe">
      <meta itemprop="description" content="郑鹤的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhengHe">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          从 MapReduce 到 SQL
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-08-06 22:16:08" itemprop="dateCreated datePublished" datetime="2022-08-06T22:16:08+00:00">2022-08-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-01-06 13:51:11" itemprop="dateModified" datetime="2023-01-06T13:51:11+00:00">2023-01-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%AE%9E%E8%B7%B5/" itemprop="url" rel="index"><span itemprop="name">实践</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2022/08/06/map-reduce-from-scratch/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2022/08/06/map-reduce-from-scratch/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>在最近的工作中，为了做数据分析，我开始写一些复杂的 HiveSQL。每次执行 HiveSQL 时，都会看到 Map/Reduce jobs 被调度、执行，直到最后展示出数据。渐渐地我心中多了两个疑问：</p>
<ol type="1">
<li><p>MapReduce 引擎如何工作？</p></li>
<li><p>SQL 是如何被翻译成 MapReduce job 的？</p></li>
</ol>
<p>为了解决这两个疑问，我用比较熟悉的 Go 语言实现了一个玩具版本的 MapReduce 引擎，然后基于此实现基本的 select，join。</p>
<blockquote>
<p>本文相关的源码放在仓库 <a target="_blank" rel="noopener" href="https://github.com/ZhengHe-MD/pset/tree/main/map-reduce/go/mapreduce">ZhengHe-MD/pset · GitHub</a> 中，欢迎查阅。</p>
</blockquote>
<span id="more"></span>
<h2 id="mapreduce-的基本过程">1. MapReduce 的基本过程</h2>
<p>如果你读过 Google 的这篇论文 <a target="_blank" rel="noopener" href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/mapreduce-osdi04.pdf">MapReduce: Simplified Data Processing on Large Clusters</a>，可以直接跳过本节。如果你没读过或者有些遗忘，则不妨往下看。</p>
<p>MapReduce job 的一般执行过程如下图所示：</p>
<p><img src="./map-reduce-word-count.png" /></p>
<blockquote>
<p>注：图中每个方块代表一个文件</p>
</blockquote>
<ol type="1">
<li><p>输入数据是一个巨大的文件，需要先把它切分成若干子文件；</p></li>
<li><p>Map 过程将单个子文件中的原始数据转化成一组键值对。键值对中键值的含义由开发者定义。每个子文件产生的键值对会按照对应的键散列到若干个临时文件中，在下文中我将称这些临时文件为 mapped file。键的散列值 (<code>hash(key)</code>) 相同的数据会被写入同一个临时文件；</p></li>
<li><p>Reduce 过程先读取对应散列值的临时文件，根据需要重排里边的键值对，最后依照目标聚合数据；</p></li>
<li><p>Reduce 产出的文件，既可以被用作另一个 MapReduce job 的输入子文件，即第 1 步的输出结果，也可以被直接合并成结果文件输出。</p></li>
</ol>
<p>以图中的「词频计算」为例，Map 过程读取文件中的每一个词，生成键为词语、值为常数 1 的键值对，如 "Deer, 1"、"Car, 1"。键散列值相同的数据会被散列到相同的临时文件中，交给对应的 Reduce 过程。Reduce 过程获取散列值相同的键值对后，先做一次排序，使键相同的数据物理上相邻，如图中的 3 个 "Car, 1"，然后直接加总计数值即可得到 "Car, 3"，即单词 "Car" 出现 3 次。合并所有输出文件就得到了所有词语的频度统计结果。</p>
<p>从性能上看，Map 和 Reduce 的执行实例可以依据 job 的大小自由扩展，使得 Map 阶段和 Reduce 阶段各自可以横向扩容计算能力。另外，整个过程中的发生的数据读写形式只有顺序 I/O，能充分满足大数据对吞吐的需求。</p>
<h2 id="实现一个玩具版-mapreduce-引擎">2. 实现一个玩具版 MapReduce 引擎</h2>
<blockquote>
<p>💡 What I cannot create, I do not understand.</p>
</blockquote>
<p>在进入正文之前，我首先声明：这个引擎并不是我从无到有造出来的。在开干之前，我想起 4 年前做过的 MIT-6.824 作业中第一个 lab 就是 MapReduce。于是我先通读了一遍课程设计者提供的源码，随后才撸起袖子开干，这个过程肯定会有一些参考和借鉴。</p>
<h3 id="领域实体-entities">2.1 领域实体 (Entities)</h3>
<p>MapReduce 引擎需要能接收用户提交的任务，并将它拆解成多个小的计算 (map/reduce) 子任务，分发到计算节点上执行，过程如下图所示：</p>
<p><img src="./map-reduce-entities.png" /></p>
<p>这里至少涉及 5 个实体：Cluster、Master、Worker、Job 和 Task。Cluster 负责管理集群的元信息、启动和关闭；master 节点负责 worker 节点的注册、发现，接收用户提交的 job，拆解成子任务 task，分发给 worker 节点执行。由于 map 与 reduce 子任务在元数据和执行过程并不相同，为了源码的可读性和可维护性，Task 又被进一步拆分成 MapTask 与 ReduceTask 两个子类。</p>
<blockquote>
<p>备注：为了表述清晰，下文中会将执行 map task 的 worker 称为 mapper，执行 reduce task 的 worker 称为 reducer。</p>
</blockquote>
<h3 id="领域过程-interfaces">2.2 领域过程 (Interfaces)</h3>
<p>谈到 MapReduce 引擎的领域过程，自然少不了 map 和 reduce。此外，数据在计算子任务之间是以文件的形式共享，因此数据的编解码也是引擎里重要的过程。</p>
<p>mapper 将输入数据按计算目标解析成键值对：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mapper is the interface that wraps the basic Map method.</span></span><br><span class="line"><span class="keyword">type</span> Mapper <span class="keyword">interface</span> &#123;</span><br><span class="line">    Map(data []<span class="keyword">byte</span>) ([]KeyValue, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>reducer 将键相同的键值对聚合，由于输出的键与输入相同，在返回值中只需要给出计算结果即可：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reducer is the interface that wraps the basic Reduce method.</span></span><br><span class="line"><span class="keyword">type</span> Reducer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Reduce(key <span class="keyword">string</span>, values []<span class="keyword">string</span>) (<span class="keyword">string</span>, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于每个计算任务的 map 和 reduce 过程本就是为了完成某个特定的计算目标，二者的逻辑有很密切的联系，因此工程师一般会对二者同时设计、编码和测试。于是在这里额外定义一个 MapReducer，方便开发者管理 mapper 和 reducer 的逻辑。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MapReducer is the interface that groups the basic Map and Reduce methods.</span></span><br><span class="line"><span class="keyword">type</span> MapReducer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Mapper</span><br><span class="line">    Reducer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Encoder 和 Decoder 定义数据的编解码过程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Encoder is the interface that wraps the basic Encode method.</span></span><br><span class="line"><span class="keyword">type</span> Encoder <span class="keyword">interface</span> &#123;</span><br><span class="line">    Encode(v any) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Decoder is the interface that wraps the basic Decode method.</span></span><br><span class="line"><span class="keyword">type</span> Decoder <span class="keyword">interface</span> &#123;</span><br><span class="line">    Decode(v any) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽管在实现过程中使用的是标准库中的 json.Encoder 和 json.Decoder，但这里很有必要将这两个过程提炼出来，强调它的重要性。</p>
<h3 id="业务规则-business-rules">2.3 业务规则 (Business Rules)</h3>
<h4 id="一次任务关联的文件">2.3.1 一次任务关联的文件</h4>
<p>在一次 MapReduce job 执行过程中会涉及多少个不同的文件？假设共有 M 个 map task，R 个 reduce task，我以文件视角画了一张示意图：</p>
<p><img src="./map-reduce-files.png" /></p>
<p>一般拆分后的输入子文件会被放在文件系统 (如 HDFS) 的某个目录下。目录中文件的数量即为需要执行的 map task 数量 M。由于在 reduce 阶段，我们需要将键相同的键值对放进同一个 reduce task 中处理，而 map task 的输入文件中可能包含任意键值对，因此每个 map task 在执行时都可能输出到 R 个 mapped file 里，中间文件的总数为 MR。每个 reduce task 会读取散列值相同的所有 mapped file，然后执行排序和 reduce 逻辑，输出到一个 reduced file 里。将所有 reduced files 合并就能得到最终结果文件。</p>
<p>综上所述，一次任务关联的文件总数为 <code>M + MR + R + 1</code>。在我们的计算引擎中，用户在提交任务时，会通过输入文件目录 (InputDir) 所含的文件数量确定 M，通过 Job 中的字段 R 指定 R。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Job <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id            <span class="keyword">string</span></span><br><span class="line">    InputDir      <span class="keyword">string</span> <span class="comment">// the directory where input files reside</span></span><br><span class="line">    OutputDir     <span class="keyword">string</span> <span class="comment">// the directory where output files reside</span></span><br><span class="line">    ProcessorName <span class="keyword">string</span> <span class="comment">// the name of a MapReducer defined in mapreducers.go</span></span><br><span class="line">    R             <span class="keyword">int</span>    <span class="comment">// number of reduce tasks</span></span><br><span class="line"></span><br><span class="line">    operation *Operation <span class="comment">// job status</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="执行-mapreduce-task">2.3.2 执行 Map/Reduce Task</h4>
<p>引擎中，MapTask 和 ReduceTask 之间有一个隐藏的约定 —— mapped file 的命名规则：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mappedFile constructs the name of the mapped file which a MapTask</span></span><br><span class="line"><span class="comment">// generates for the corresponding ReduceTask.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mappedFile</span><span class="params">(jobId <span class="keyword">string</span>, mapTask <span class="keyword">string</span>, reduceTask <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;mrtmp.%s-%s-%s&quot;</span>, jobId, mapTask, reduceTask)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个 mapped file 名字由 job，map task 和 reduce task 三者的标识共同决定。通过这个约定，mapper 和 reducer 都能够利用 M、R 以及 job 信息计算得到所有 mapped files 的地址。</p>
<h5 id="maptask">2.3.2.1 MapTask</h5>
<p>以下是 map task 的数据结构，其中 <code>InputFile</code> 是输入的子文件。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MapTask provides all the information needed to run a map task.</span></span><br><span class="line"><span class="keyword">type</span> MapTask <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id        <span class="keyword">string</span></span><br><span class="line">    InputFile <span class="keyword">string</span> <span class="comment">// the input file to map phase.</span></span><br><span class="line">    Job       *Job</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行 map 过程时，需要打开 1 个输入文件和 R 个输出文件，利用开发者自定义的 mapper 将原始数据转化成键值对，然后根据键的哈希值选择数据应被写进的输出文件：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mt *MapTask)</span> <span class="title">Do</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1. 打开输入文件，并读取原始数据</span></span><br><span class="line">    byt, err := ioutil.ReadFile(mt.InputFile)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 将原始数据传给开发者自定义的 Map </span></span><br><span class="line">    kvs, err := mapReducer.Map(byt)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 打开 mapped files</span></span><br><span class="line">    mappedFiles := <span class="built_in">make</span>([]*os.File, <span class="number">0</span>, mt.Job.R)</span><br><span class="line">    encoders := <span class="built_in">make</span>([]Encoder, <span class="number">0</span>, mt.Job.R)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 4. 遍历键值对，并利用 encoder 写出到相应的输出文件</span></span><br><span class="line">    <span class="keyword">var</span> hsh <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> _, kv := <span class="keyword">range</span> kvs &#123;</span><br><span class="line">        <span class="keyword">if</span> hsh, err = hash(kv.Key); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> err = encoders[hsh%mt.Job.R].Encode(&amp;kv); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="reducetask">2.3.2.2 ReduceTask</h5>
<p>以下是 reduce task 的数据结构：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReduceTask provides all the information needed to run a reduce task.</span></span><br><span class="line"><span class="keyword">type</span> ReduceTask <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id  <span class="keyword">string</span></span><br><span class="line">    M   <span class="keyword">int</span> <span class="comment">// number of map tasks</span></span><br><span class="line">    Job *Job</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行 reduce 时，需要打开 M 个输入文件和 1 个输出文件，先读取 M 个输入文件中的所有数据，按键排序后，将键相同的数据一组一组地交由开发者定义的 reducer 处理，并将得到的计算结果写进输出文件。在论文中提到过，如果无法在内存中完成所有数据的排序，将使用外部排序算法，本项目为了简单直接忽略了这种情况。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rt *ReduceTask)</span> <span class="title">Do</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> kvs []KeyValue</span><br><span class="line">    <span class="comment">// 1. 读取 M 个输入文件中的键值对到 kvs 中</span></span><br><span class="line">    <span class="keyword">var</span> mf *os.File</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; rt.M; i++ &#123;</span><br><span class="line">        mf, err = os.Open(mappedFile(rt.Job.Id, strconv.Itoa(i), rt.Id))</span><br><span class="line">        <span class="comment">// handle err and close file...</span></span><br><span class="line">        <span class="keyword">var</span> shard []KeyValue</span><br><span class="line">        <span class="comment">// decode map file into shard...</span></span><br><span class="line">        kvs = <span class="built_in">append</span>(kvs, shard...)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 按键排序</span></span><br><span class="line">    sort.Slice(kvs, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> kvs[i].Key &lt; kvs[j].Key</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 3. 将键相同的数据一组一组地传入 Reduce</span></span><br><span class="line">    <span class="keyword">var</span> rkvs []KeyValue</span><br><span class="line">    <span class="keyword">var</span> k, v <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">var</span> vs []<span class="keyword">string</span></span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i &lt; <span class="built_in">len</span>(kvs) &#123;</span><br><span class="line">        k, vs = kvs[i].Key, <span class="built_in">append</span>(vs, kvs[i].Value)</span><br><span class="line">        <span class="keyword">for</span> i+<span class="number">1</span> &lt; <span class="built_in">len</span>(kvs) &amp;&amp; kvs[i+<span class="number">1</span>].Key == k &#123;</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            vs = <span class="built_in">append</span>(vs, kvs[i].Value)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> v, err = mapReducer.Reduce(k, vs); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        rkvs = <span class="built_in">append</span>(rkvs, KeyValue&#123;Key: k, Value: v&#125;)</span><br><span class="line">        vs = vs[:<span class="number">0</span>]</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 将结果写出</span></span><br><span class="line">    <span class="comment">// (省略)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="执行引擎">2.3.3 执行引擎</h4>
<h5 id="通信协议">2.3.3.1 通信协议</h5>
<p>MapReduce job 的执行过程中涉及到了进程间通信，本项目使用 go 标准库里的 <code>net/rpc</code> 作为通信协议。MapReduce 集群中有两种节点：Master 和 Worker，Master 负责任务的调度和结果汇总，Worker 负责执行具体的计算过程。</p>
<p>master 中需要存储所有注册节点的地址，即结构体 Master 中的 workers 字段。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Master is the concrete type for Master node described in the original paper.</span></span><br><span class="line"><span class="keyword">type</span> Master <span class="keyword">struct</span> &#123;</span><br><span class="line">    Address <span class="keyword">string</span></span><br><span class="line">    lsn     net.Listener</span><br><span class="line"></span><br><span class="line">    mu      sync.Mutex             <span class="comment">// protects the following fields.</span></span><br><span class="line">    wi      <span class="keyword">int</span>                    <span class="comment">// index of current worker, used to implement round-robin strategy.</span></span><br><span class="line">    workers []<span class="keyword">string</span>               <span class="comment">// registered worker addresses.</span></span><br><span class="line">    clients <span class="keyword">map</span>[<span class="keyword">string</span>]*rpc.Client <span class="comment">// map worker (address) to it&#x27;s rpc client.</span></span><br><span class="line">    jobs    <span class="keyword">map</span>[<span class="keyword">string</span>]*Job        <span class="comment">// in-memory job store, which maps operation id to job.</span></span><br><span class="line"></span><br><span class="line">    shutdown <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单个 worker 启动后通过 master 暴露的 Register 接口将自己的服务信息注册上去，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RegisterArgs represents arguments passed when a worker node calls Register.</span></span><br><span class="line"><span class="keyword">type</span> RegisterArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// the communication endpoint of worker process,</span></span><br><span class="line">    <span class="comment">// such as IPC socket or Network socket</span></span><br><span class="line">    Worker <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register is called when a Worker node wants to register itself to the Master node.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">Register</span><span class="params">(args *RegisterArgs, _ *<span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    m.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> m.mu.Unlock()</span><br><span class="line">    <span class="comment">// ignore all sanity checks.</span></span><br><span class="line">    m.workers = <span class="built_in">append</span>(m.workers, args.Worker)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后，master 就可以根据用户提交的 job，将对应的 map task 和 reduce task 派发给若干 worker 节点，这里需要使用的是 worker 节点提供的 DoMapTask 和 DoReduceTask 接口。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DoMapTaskArgs represents arguments passed to Worker.DoMapTask.</span></span><br><span class="line"><span class="keyword">type</span> DoMapTaskArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">    MapTask *MapTask</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DoMapTask executes the given map task synchronously.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Worker)</span> <span class="title">DoMapTask</span><span class="params">(args *DoMapTaskArgs, _ *<span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    log.Printf(<span class="string">&quot;worker %s start doing map task %s\n&quot;</span>, w.address, args.MapTask.Id)</span><br><span class="line">    <span class="keyword">return</span> args.MapTask.Do()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DoReduceTaskArgs represents arguments passed to Worker.DoReduceTask.</span></span><br><span class="line"><span class="keyword">type</span> DoReduceTaskArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">    ReduceTask *ReduceTask</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DoReduceTask executes the given reduce task synchronously.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Worker)</span> <span class="title">DoReduceTask</span><span class="params">(args *DoReduceTaskArgs, _ *<span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    log.Printf(<span class="string">&quot;worker %s start doing reduce task %s\n&quot;</span>, w.address, args.ReduceTask.Id)</span><br><span class="line">    <span class="keyword">return</span> args.ReduceTask.Do()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="顺序引擎">2.3.3.2 顺序引擎</h5>
<p>顺序执行引擎只用一个 worker 来执行所有的 map/reduce task，其本身的存在意义并不大，主要用于验证概念，确认核心流程的正确性。实现顺序引擎后再实现分布式引擎就会更胸有成竹一些。</p>
<p>忽略异常处理逻辑，顺序引擎的大体执行过程如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sequential runs the map/reduce job sequentially on an arbitrary Worker node.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">sequential</span><span class="params">(args *SubmitArgs, operation *Operation)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    job := args.Job</span><br><span class="line">    files, _ := ioutil.ReadDir(job.InputDir)</span><br><span class="line">    client, _ := m.getClient()</span><br><span class="line">    <span class="comment">// map phase</span></span><br><span class="line">    <span class="keyword">for</span> i, file := <span class="keyword">range</span> files &#123;</span><br><span class="line">        doTaskArgs := &amp;DoMapTaskArgs&#123;</span><br><span class="line">            MapTask: &amp;MapTask&#123;</span><br><span class="line">                Id:        strconv.Itoa(i),</span><br><span class="line">                InputFile: path.Join(job.InputDir, file.Name()),</span><br><span class="line">                Job:       job,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">        _ = client.Call(<span class="string">&quot;Worker.DoMapTask&quot;</span>, doTaskArgs, <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// reduce phase</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; job.R; i++ &#123;</span><br><span class="line">        doTaskArgs := &amp;DoReduceTaskArgs&#123;</span><br><span class="line">            ReduceTask: &amp;ReduceTask&#123;</span><br><span class="line">                Id:  strconv.Itoa(i),</span><br><span class="line">                Job: job,</span><br><span class="line">                M:   <span class="built_in">len</span>(files),</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">        _ = client.Call(<span class="string">&quot;Worker.DoReduceTask&quot;</span>, doTaskArgs, <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// remove temporary files...</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="分布式引擎">2.3.3.3 分布式引擎</h5>
<p>与顺序引擎不同，分布式引擎会将所有 map/reduce task 分发给当前可用的多个 worker，实现计算的横向扩容。核心逻辑与顺序引擎大体相同，只是会额外使用 <code>sync.WaitGroup</code> 在 Map 阶段和 Reduce 阶段分别实现计算逻辑的 fan-out 和 fan-in。Map 阶段实现片段如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// distributed runs the map/reduce job on available Worker nodes in a distributed manner.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">distributed</span><span class="params">(args *SubmitArgs, operation *Operation)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// map phase</span></span><br><span class="line">    <span class="keyword">var</span> mwg sync.WaitGroup</span><br><span class="line">    mwg.Add(<span class="built_in">len</span>(files))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> client *rpc.Client</span><br><span class="line">    <span class="keyword">for</span> i, file := <span class="keyword">range</span> files &#123;</span><br><span class="line">        doTaskArgs := &amp;DoMapTaskArgs&#123;</span><br><span class="line">            MapTask: &amp;MapTask&#123;</span><br><span class="line">                Id:        strconv.Itoa(i),</span><br><span class="line">                InputFile: path.Join(job.InputDir, file.Name()),</span><br><span class="line">                Job:       job,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        client, _ = m.getClient()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            rpcErr := client.Call(<span class="string">&quot;Worker.DoMapTask&quot;</span>, doTaskArgs, <span class="literal">nil</span>)</span><br><span class="line">            <span class="keyword">if</span> rpcErr != <span class="literal">nil</span> &#123;</span><br><span class="line">                operation.Error = rpcErr</span><br><span class="line">            &#125;</span><br><span class="line">            mwg.Done()</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    mwg.Wait()</span><br><span class="line">    log.Println(<span class="string">&quot;MapTask phase done.&quot;</span>)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="api">2.4 API</h3>
<p>对用户而言，MapReduce 引擎只需要暴露提交计算任务的接口即可。对于不同的计算任务，所消耗的时间可从分钟级、小时级到天级甚至更长的时间，同步的接口并不是一个好的选择。这里借鉴了 googleapis 中的 <a target="_blank" rel="noopener" href="https://github.com/googleapis/googleapis/tree/master/google/longrunning">Long Running Operations API</a>，用户通过 SubmitJob 接口提交 MapReduce job，然后得到一个 Operation 结构，表示一个正在执行的任务：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SubmitArgs represents arguments passed when a client calls SubmitJob.</span></span><br><span class="line"><span class="keyword">type</span> SubmitArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">    Job         *Job <span class="comment">// description of the job to submit</span></span><br><span class="line">    Distributed <span class="keyword">bool</span> <span class="comment">// indicates whether the job should be scheduled distributively</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Operation is the reply from Master node when a client calls SubmitJob.</span></span><br><span class="line"><span class="keyword">type</span> Operation <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id    <span class="keyword">string</span></span><br><span class="line">    Done  <span class="keyword">bool</span></span><br><span class="line">    Error error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SubmitJob is called when a client wants to submit a new job to Master node.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">SubmitJob</span><span class="params">(args *SubmitArgs, operation *Operation)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用户可以利用 operation 信息和 GetOperation 接口随时查询任务的执行状态：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetOperationArgs represents arguments passed when a client calls GetOperation.</span></span><br><span class="line"><span class="keyword">type</span> GetOperationArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetOperation requests the operation status of a map/reduce job.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">GetOperation</span><span class="params">(args *GetOperationArgs, operation *Operation)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="demo">2.5 Demo</h3>
<p>在 Go 运行时中动态加载用户自定义的函数并不是一件很容易的事，由于这部分功能并非本项目的主要关注点，本项目直接将每个任务对应的 MapReducer 统一定义到项目源码的 <a target="_blank" rel="noopener" href="https://github.com/ZhengHe-MD/pset/blob/main/map-reduce/go/mapreduce/mapreducers.go">mapreducers.go</a> 中。受限于这个选择，这个玩具版 MapReduce 引擎并无法真正支持用户提交任意自定义 MapReduce job。</p>
<h4 id="wordcount">2.5.1 WordCount</h4>
<p>WordCount 即「词频计算」，是 MapReduce 世界的 "hello, world"：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WordCount <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wc WordCount)</span> <span class="title">Map</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="params">(kvs []KeyValue, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, byt := <span class="keyword">range</span> bytes.Fields(data) &#123;</span><br><span class="line">        kvs = <span class="built_in">append</span>(kvs, KeyValue&#123;</span><br><span class="line">            Key:   <span class="keyword">string</span>(byt),</span><br><span class="line">            Value: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wc WordCount)</span> <span class="title">Reduce</span><span class="params">(key <span class="keyword">string</span>, values []<span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> strconv.Itoa(<span class="built_in">len</span>(values)), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WordCount 的 mapper 只需要将文本分词后输出 "[word], 1"。reducer 执行时，任意一个词，如 "hello" 对应的键值对 "hello, 1" 会被合并，因此这里 Reduce 函数的输入 key 为 "hello"，values 为一个字符串数组 <code>["1", "1", ..., "1"]</code>，该函数只需返回这个数组的长度即得到单词 "hello" 的出现次数。</p>
<p>以莎士比亚的节选为例，执行测试如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">t.Run(<span class="string">&quot;word count (sequential)&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    operation := <span class="built_in">new</span>(Operation)</span><br><span class="line">    err = client.Call(<span class="string">&quot;Master.SubmitJob&quot;</span>, &amp;SubmitArgs&#123;</span><br><span class="line">        Job: &amp;Job&#123;</span><br><span class="line">            InputDir:      <span class="string">&quot;./mixtures/wc/input&quot;</span>,</span><br><span class="line">            OutputDir:     <span class="string">&quot;./mixtures/wc/output&quot;</span>,</span><br><span class="line">            ProcessorName: <span class="string">&quot;wc&quot;</span>,</span><br><span class="line">            R:             <span class="number">2</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        Distributed: <span class="literal">false</span>,</span><br><span class="line">    &#125;, operation)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        t.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    _wait(t, client, operation)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>可以在 <code>./mixtures/wc/output</code> 文件夹中看到相应的 reduced files，其中一个输出片段如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;Key&quot;:&quot;Feed&#x27;st&quot;,&quot;Value&quot;:&quot;1&quot;&#125;</span><br><span class="line">&#123;&quot;Key&quot;:&quot;From&quot;,&quot;Value&quot;:&quot;1&quot;&#125;</span><br><span class="line">&#123;&quot;Key&quot;:&quot;His&quot;,&quot;Value&quot;:&quot;1&quot;&#125;</span><br><span class="line">&#123;&quot;Key&quot;:&quot;How&quot;,&quot;Value&quot;:&quot;1&quot;&#125;</span><br><span class="line">&#123;&quot;Key&quot;:&quot;Pity&quot;,&quot;Value&quot;:&quot;1&quot;&#125;</span><br><span class="line">&#123;&quot;Key&quot;:&quot;Shall&quot;,&quot;Value&quot;:&quot;1&quot;&#125;</span><br><span class="line">&#123;&quot;Key&quot;:&quot;This&quot;,&quot;Value&quot;:&quot;1&quot;&#125;</span><br><span class="line">&#123;&quot;Key&quot;:&quot;Thou&quot;,&quot;Value&quot;:&quot;1&quot;&#125;</span><br><span class="line">&#123;&quot;Key&quot;:&quot;When&quot;,&quot;Value&quot;:&quot;1&quot;&#125;</span><br><span class="line">&#123;&quot;Key&quot;:&quot;Will&quot;,&quot;Value&quot;:&quot;1&quot;&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>克隆仓库 <a target="_blank" rel="noopener" href="https://github.com/ZhengHe-MD/pset/tree/main/map-reduce/go/mapreduce">ZhengHe-MD/pset · GitHub</a>，执行对应的测试看看吧？</p>
<h4 id="average">2.5.2 Average</h4>
<p>假设有一个巨大的文件，文件中每行包含一个整数，想要计算这些整数的平均值，要怎么做？求平均值需要两个值：<code>cnt</code> 和 <code>sum</code>。在 Map 阶段我们可以针对每个子文件输出一个或多个 <code>cnt</code> 和 <code>sum</code>，然后在 Reduce 阶段计算 <code>total(sum)/total(cnt)</code> 即可，相关逻辑如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Avg <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Avg)</span> <span class="title">Map</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="params">(kvs []KeyValue, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> cnt, sum, num <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> _, byt := <span class="keyword">range</span> bytes.Fields(data) &#123;</span><br><span class="line">        num, err = strconv.Atoi(<span class="keyword">string</span>(byt))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        sum += num</span><br><span class="line">        cnt += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kvs = <span class="built_in">append</span>(kvs,</span><br><span class="line">        KeyValue&#123;Key: <span class="string">&quot;sum&quot;</span>, Value: strconv.Itoa(sum)&#125;,</span><br><span class="line">        KeyValue&#123;Key: <span class="string">&quot;cnt&quot;</span>, Value: strconv.Itoa(cnt)&#125;)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Avg)</span> <span class="title">Reduce</span><span class="params">(key <span class="keyword">string</span>, values []<span class="keyword">string</span>)</span> <span class="params">(value <span class="keyword">string</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum, num <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> values &#123;</span><br><span class="line">        num, err = strconv.Atoi(v)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        sum += num</span><br><span class="line">    &#125;</span><br><span class="line">    value = strconv.Itoa(sum)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于所有输入子文件的输出键值对都是 <code>&#123;"sum": "xxx", "cnt": "yyy"&#125;</code>，我们只能用同一个 reducer 聚合计算结果，因此 Job.R 设置为 1。</p>
<h2 id="sql-to-mapreduce-job">3. SQL to MapReduce Job</h2>
<h3 id="select">3.1 Select</h3>
<p>假设有一张大表 students 记录着学生的基本数据，这张表被横向拆分成两张子表，其内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id,name,age</span><br><span class="line">10001,Michael,24</span><br><span class="line">10002,Jill,26</span><br><span class="line">10003,Richard,18</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">id,name,age</span><br><span class="line">10004,Hazard,27</span><br><span class="line">10005,Max,25</span><br><span class="line">10010,Alice,20</span><br><span class="line">10018,Jill,29</span><br></pre></td></tr></table></figure>
<p>现在想实现这样一个查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> name <span class="operator">=</span> &quot;Jill&quot;;</span><br></pre></td></tr></table></figure>
<p>应该怎么写这个 mapreducer？用肉眼我们可以直接观察到它的结果应该是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id,name,age</span><br><span class="line">10002,Jill,26</span><br><span class="line">10018,Jill,29</span><br></pre></td></tr></table></figure>
<p>由于 select 过程只有过滤没有聚合计算，这基本意味着 reduce 阶段可以是一个 no-op。那唯一需要做的就是在 Map 阶段过滤掉不符合条件的数据即可，键值对中的键取行的唯一 id 即可，处理过程示意如下：</p>
<p><img src="./map-reduce-select.png" /></p>
<p>具体实现请参考 <a target="_blank" rel="noopener" href="https://github.com/ZhengHe-MD/pset/blob/main/map-reduce/go/mapreduce/mapreducers.go">pset/mapreducers.go at main · ZhengHe-MD/pset · GitHub</a>。</p>
<h3 id="join">3.2 Join</h3>
<p>假设有两张表，students 和 enrollments，分别记录学生信息和他们的选课信息。它们分别被拆分成两张子表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># students-1.csv</span><br><span class="line">students</span><br><span class="line">id,name,age</span><br><span class="line">10001,Michael,24</span><br><span class="line">10002,Jill,26</span><br><span class="line">10003,Richard,18</span><br><span class="line"># students-2.csv</span><br><span class="line">students</span><br><span class="line">id,name,age</span><br><span class="line">10004,Hazard,27</span><br><span class="line">10005,Max,25</span><br><span class="line">10010,Alice,20</span><br><span class="line">10011,Bob,29</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># enrollments-1.csv</span><br><span class="line">enrollments</span><br><span class="line">id,student_id,course</span><br><span class="line">20001,10002,Math</span><br><span class="line">20002,10002,Physics</span><br><span class="line">20003,10003,Math</span><br><span class="line">20004,10003,History</span><br><span class="line">20005,10001,Physics</span><br><span class="line"># enrollments-2.csv</span><br><span class="line">enrollments</span><br><span class="line">id,student_id,course</span><br><span class="line">20006,10001,History</span><br><span class="line">20007,10004,Music</span><br><span class="line">20008,10005,Music</span><br><span class="line">20009,10010,Chemistry</span><br><span class="line">20010,10011,Biology</span><br><span class="line">20010,10011,Math</span><br></pre></td></tr></table></figure>
<p>现在需要实现这样一个查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    enrollments.id,</span><br><span class="line">    enrollments.course</span><br><span class="line">    students.id,</span><br><span class="line">    students.name,</span><br><span class="line">    students.age,</span><br><span class="line"><span class="keyword">FROM</span> enrollments</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> students </span><br><span class="line">  <span class="keyword">ON</span> enrollments.student_id <span class="operator">=</span> students.id;</span><br></pre></td></tr></table></figure>
<p>应该怎么写 mapreducer？因为 join 条件是 <code>students.id = enrollments.student_id</code>，一个比较容易想到的思路就是选择被 join 的字段为键值对中的键，然后对同一个键中两表的数据执行 join，前者对应的就是 map 阶段，后者为 reduce 阶段，处理过程示意如下：</p>
<p><img src="./map-reduce-join.png" /></p>
<p>具体实现请参考 <a target="_blank" rel="noopener" href="https://github.com/ZhengHe-MD/pset/blob/main/map-reduce/go/mapreduce/mapreducers.go">pset/mapreducers.go at main · ZhengHe-MD/pset · GitHub</a>。</p>
<h2 id="尾声">4. 尾声</h2>
<p>实现这个玩具引擎，的确让我对 MapReduce 有了比通读论文更深的理解。诚然，这个引擎还有诸多问题，比如：</p>
<ol type="1">
<li><p>使用本地文件系统使得其只能利用一台机器的多个 CPU，而非多台机器</p></li>
<li><p>无法支持开发者提交自定义的 MapReducer</p></li>
<li><p>Select/Join 任务实际上有很多可能的参数组合并未支持</p></li>
<li><p>...</p></li>
</ol>
<p>不过目前的认识暂时够用，希望有一天在生产环境中遇到相关的问题，能有机会进一步探索大数据系统的奥义。</p>
<h2 id="参考">5. 参考</h2>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/mapreduce-osdi04.pdf">MapReduce: Simplified Data Processing on Large Clusters</a></p></li>
<li><p><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/general.html">MIT-6.824</a>, <a target="_blank" rel="noopener" href="https://github.com/ZhengHe-MD/distributed-system-lab-codes-2018">GitHub - ZhengHe-MD/distributed-system-lab-codes-2018</a></p></li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/ZhengHe-MD/pset/tree/main/map-reduce/go/mapreduce">ZhengHe-MD/pset · GitHub</a></p></li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="followme">
  <span>欢迎关注我的其它发布渠道</span>

  <div class="social-list">

      <div class="social-item">
        <a target="_blank" class="social-link" href="/blog/atom.xml">
          <span class="icon">
            <i class="fa fa-rss"></i>
          </span>

          <span class="label">RSS</span>
        </a>
      </div>
  </div>
</div>


        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/blog/2022/07/04/A-B-Testing/" rel="prev" title="一次实验、两种错误、三个直觉">
                  <i class="fa fa-chevron-left"></i> 一次实验、两种错误、三个直觉
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/blog/2022/09/29/my-takes-on-interviews/" rel="next" title="面试官毁掉技术面试的三大法宝">
                  面试官毁掉技术面试的三大法宝 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZhengHe</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/blog/js/comments.js"></script><script src="/blog/js/utils.js"></script><script src="/blog/js/schemes/muse.js"></script><script src="/blog/js/next-boot.js"></script>

  





  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/blog/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"zhenghe-hexo-blog","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/blog/js/third-party/comments/disqus.js"></script>

</body>
</html>
