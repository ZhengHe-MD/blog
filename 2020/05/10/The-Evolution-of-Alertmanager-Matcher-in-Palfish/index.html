<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zhenghe-md.github.io","root":"/blog/","scheme":"Pisces","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="简介 本文介绍伴鱼内部服务报警平台中匹配器模块的演进，及其利用 Lex 和 Yacc 同类工具构建 DSL 编译器的过程。是我和团队成员在伴鱼的质量工程小组的一小部分工作。 背景 报警平台是伴鱼内部各端、应用、基础设施等服务异常状态信息的集散中心。整体流程如下图所示：  信息源将信息投递给报警平台，后者将这些信息最终通过邮件、即时消息、电话呼叫的形式路由给理应关心它的人。总体而言，路由的需求可以分">
<meta property="og:type" content="article">
<meta property="og:title" content="报警平台的匹配器演进">
<meta property="og:url" content="https://zhenghe-md.github.io/blog/2020/05/10/The-Evolution-of-Alertmanager-Matcher-in-Palfish/index.html">
<meta property="og:site_name" content="ZhengHe">
<meta property="og:description" content="简介 本文介绍伴鱼内部服务报警平台中匹配器模块的演进，及其利用 Lex 和 Yacc 同类工具构建 DSL 编译器的过程。是我和团队成员在伴鱼的质量工程小组的一小部分工作。 背景 报警平台是伴鱼内部各端、应用、基础设施等服务异常状态信息的集散中心。整体流程如下图所示：  信息源将信息投递给报警平台，后者将这些信息最终通过邮件、即时消息、电话呼叫的形式路由给理应关心它的人。总体而言，路由的需求可以分">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zhenghe-md.github.io/blog/2020/05/10/The-Evolution-of-Alertmanager-Matcher-in-Palfish/alertmanager-process.jpg">
<meta property="og:image" content="https://zhenghe-md.github.io/blog/2020/05/10/The-Evolution-of-Alertmanager-Matcher-in-Palfish/route-tree.jpg">
<meta property="og:image" content="https://zhenghe-md.github.io/blog/2020/05/10/The-Evolution-of-Alertmanager-Matcher-in-Palfish/compile-process.jpg">
<meta property="og:image" content="https://zhenghe-md.github.io/blog/2020/05/10/The-Evolution-of-Alertmanager-Matcher-in-Palfish/lex-yacc-process.jpg">
<meta property="article:published_time" content="2020-05-10T00:00:00.000Z">
<meta property="article:modified_time" content="2021-11-28T12:50:04.720Z">
<meta property="article:author" content="ZhengHe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhenghe-md.github.io/blog/2020/05/10/The-Evolution-of-Alertmanager-Matcher-in-Palfish/alertmanager-process.jpg">

<link rel="canonical" href="https://zhenghe-md.github.io/blog/2020/05/10/The-Evolution-of-Alertmanager-Matcher-in-Palfish/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>报警平台的匹配器演进 | ZhengHe</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-172943223-1"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-172943223-1');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"] > svg a {
  fill: blue;
  stroke: blue;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container {
  overflow: auto hidden;
}

mjx-container + br {
  display: none;
}
</style><link rel="alternate" href="/blog/atom.xml" title="ZhengHe" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ZhengHe</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right"></div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/blog/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhenghe-md.github.io/blog/2020/05/10/The-Evolution-of-Alertmanager-Matcher-in-Palfish/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpeg">
      <meta itemprop="name" content="ZhengHe">
      <meta itemprop="description" content="郑鹤的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhengHe">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          报警平台的匹配器演进
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-10 00:00:00" itemprop="dateCreated datePublished" datetime="2020-05-10T00:00:00+00:00">2020-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-28 12:50:04" itemprop="dateModified" datetime="2021-11-28T12:50:04+00:00">2021-11-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/system-design/" itemprop="url" rel="index">
                    <span itemprop="name">system design</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2020/05/10/The-Evolution-of-Alertmanager-Matcher-in-Palfish/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/05/10/The-Evolution-of-Alertmanager-Matcher-in-Palfish/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="简介">简介</h2>
<p>本文介绍伴鱼内部服务报警平台中匹配器模块的演进，及其利用 Lex 和 Yacc 同类工具构建 DSL 编译器的过程。是我和团队成员在伴鱼的质量工程小组的一小部分工作。</p>
<h3 id="背景">背景</h3>
<p>报警平台是伴鱼内部各端、应用、基础设施等<strong>服务异常状态信息的集散中心</strong>。整体流程如下图所示：</p>
<p><img src="/blog/2020/05/10/The-Evolution-of-Alertmanager-Matcher-in-Palfish/alertmanager-process.jpg" height="150px"></p>
<p>信息源将信息投递给报警平台，后者将这些信息最终通过邮件、即时消息、电话呼叫的形式<strong>路由</strong>给理应关心它的人。总体而言，路由的需求可以分为以下几种：</p>
<ul>
<li>路由给服务的负责人及其团队</li>
<li>路由给服务依赖方人员及其团队</li>
<li>路由给所有值班人员所在的即时消息群</li>
</ul>
<p>为了满足这样的需求，报警平台采用树状结构组织路由信息，如下图所示：</p>
<p><img src="/blog/2020/05/10/The-Evolution-of-Alertmanager-Matcher-in-Palfish/route-tree.jpg" height="350px"></p>
<p>每个节点是一个路由节点，节点上可以挂载不同的规则，如抑制规则、通知规则；也可以存放不同的配置信息，如触发报警的阈值，以及相关负责人及其团队的联系方式。</p>
<p>根路由是所有异常信息的必经之路，经过这里的信息会路由给所有值班人员；一级子路由节点是所有的服务，经过这里的信息会路由给该服务的负责人及其团队；如果有其它团队想要订阅某服务的异常消息，如 <em>Service A</em> 团队想要了解 <em>Service B</em> 的崩溃 (panic) 信息，则可以在 <em>Service B</em> 节点下创建子路由 <em>Service B Panic</em>，并在上面配置 <em>Service A</em> 团队的联系方式，从而达到订阅目的。</p>
<p>那么如何判断一条报警信息将经过哪些路由节点，一条规则是否起作用？这就需要引入本文的主角：<strong>匹配器 (matcher)</strong>，每个路由、每条规则上都会挂载一个匹配器，当它成功匹配到报警信息时，路由和规则就会生效。一条典型的报警信息会有许多信息，我们不妨将它看作是任意数量的键值对，如：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">"title"</span>: <span class="string">"Web 服务 ServiceB 崩溃报警"</span>,</span><br><span class="line">  <span class="attr">"source"</span>: <span class="string">"192.168.0.1"</span>,</span><br><span class="line">  <span class="attr">"error_type"</span>: <span class="string">"panic"</span>,</span><br><span class="line">  <span class="attr">"project_name"</span>: <span class="string">"ServiceB"</span>,</span><br><span class="line">  <span class="attr">"project_source"</span>: <span class="string">"web"</span>,</span><br><span class="line">  <span class="attr">"details"</span>: <span class="string">"(call stack)"</span>,</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>我们可以试着写出路由节点 <em>ServiceB</em> 及 <em>Service B Panic</em> 的匹配器：</p>
<ul>
<li><em>ServiceB</em>：project_source 为 web 且 project_name 为 ServiceB</li>
<li><em>Service B Panic</em>：project_source 为 web，且 project_name 为 Service B，且 error_type 为 panic</li>
</ul>
<p>报警平台的用户需要亲自配置部分路由和规则，能否定制一套简单、易上手的 DSL？如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">project_source = "web" AND project_name = "ServiceB"</span><br></pre></td></tr></table></figure>
<p>这样即使用户不是工程师，看过几个例子后也能熟练地书写匹配表达式。</p>
<h3 id="匹配表达式定义">匹配表达式定义</h3>
<p>匹配器表达式由原始表达式和复合表达式构成。原始表达式是最小的匹配器，有<strong>完全匹配</strong>和<strong>正则匹配</strong>两种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 完全匹配</span><br><span class="line">project_source = "web"</span><br><span class="line"># 正则匹配</span><br><span class="line">details =~ "duplicate key when insert"</span><br></pre></td></tr></table></figure>
<p>原始表达式的左手边是报警信息的标签，不带双引号；原始表达式的右手边是匹配文本，带双引号。不同的原始表达式可通过二元关系运算，AND (且) 和 OR (或) ，组合成复合表达式如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">project_source = "web" AND project_name = "ServiceB" OR "error_type" = "panic"</span><br></pre></td></tr></table></figure>
<p>类似于乘除之于加减，AND 的优先级大于 OR，如果要改变优先级，可通过增加括号来实现，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">project_source = "web" AND (project_name = "ServiceB" OR "error_type" = "panic")</span><br></pre></td></tr></table></figure>
<h2 id="编译过程">编译过程</h2>
<p>一个完整的编译过程大致分三阶段：</p>
<p><img src="/blog/2020/05/10/The-Evolution-of-Alertmanager-Matcher-in-Palfish/compile-process.jpg" height="350px"></p>
<ol type="1">
<li>前端：验证源码的语法和语义，并解析成中间表述 (Immediate Representation, IR)</li>
<li>中端：针对 IR 作一些与目标 CPU 架构无关的优化</li>
<li>后端：针对目标 CPU 架构优化并生成可执行的机器指令</li>
</ol>
<p>我们也可以将匹配器表达式理解成一门语言，但我们只需要将它转化成合理的内存数据结构即可，因此这里只涉及到完整编译过程的前端：</p>
<ol type="1">
<li>词法分析 (Lexical Analysis)：将完整的语句拆成词语和标点符号</li>
<li>语法分析 (Syntax Analysis)：根据语法规范，将词语和标点符合组合成抽象语法树 (AST)</li>
<li>语义分析 (Semantic Analysis)：向语法树中添加语义信息，完成校验变量类型等各种语义检查</li>
<li>生成中间表述 (IR Generation)：转化成合理的内存数据结构</li>
</ol>
<p>以下就是匹配表达式的 IR：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PrimitiveMatcher <span class="keyword">struct</span> {</span><br><span class="line">	Label    <span class="keyword">string</span></span><br><span class="line">	Text     <span class="keyword">string</span></span><br><span class="line">	IsRegexp <span class="keyword">bool</span></span><br><span class="line">	re       *regexp.Regexp</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Matcher <span class="keyword">struct</span> {</span><br><span class="line">	PrimitiveMatcher *PrimitiveMatcher</span><br><span class="line">	IsCompound       <span class="keyword">bool</span></span><br><span class="line">	Operator    		 MatcherOperator</span><br><span class="line">	Operands    		 []*Matcher</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>其中 Matcher 既可以是原始匹配器 (表达式) 也可以是复合匹配器 (表达式)。</p>
<p>下面分别介绍报警平台匹配器编译器的两个版本实现，Matcher Compiler V1 (MCV1) 和 Matcher Compiler V2 (MCV2)。</p>
<h2 id="matcher-compiler-v1">Matcher Compiler V1</h2>
<p>在实现 MCV1 时我们并未从编译的角度看待这个模块，而只是单纯地想实现从表达式到 <em>IR</em> 的转化。凭借工程师的本能，MCV1 将编译的前端处理过程分成 3 步：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">err = m.parseToken()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">err = m.toElements()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> m.buildMatcher()</span><br></pre></td></tr></table></figure>
<h3 id="parsetoken">parseToken</h3>
<p><code>parseToken</code> 将原始表达式转化成一个词语数组，是词法分析的雏形，其整体过程如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, c := m.expr {</span><br><span class="line">  hasLeftDoubleQuote := <span class="literal">false</span></span><br><span class="line">  <span class="keyword">switch</span> c {</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">    	<span class="comment">//...</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">    	<span class="comment">//...</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'='</span>:</span><br><span class="line">    	<span class="comment">//...</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'~'</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  	<span class="keyword">default</span>:</span><br><span class="line">    	<span class="comment">//...</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><code>parseToken</code> 需要许多状态，如：</p>
<ul>
<li>是否在括号内</li>
<li>是否在引号内</li>
<li>遇到 <code>~</code> 要考虑是否会和上一个字符共同组成 <code>=~</code></li>
<li>...</li>
</ul>
<p>由于状态较多，要同时考虑各种状态及其之间的转化过程，使得 <code>parseToken</code> 足够健壮，过程烧脑且容易出错。</p>
<h3 id="toelements">toElements</h3>
<p><code>toElements</code> 遍历词语数组，构建其中的原始表达式，可以看作理解成是语法分析和语义分析的一部分，其整体过程如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, word := <span class="keyword">range</span> m.words {</span><br><span class="line">  <span class="keyword">switch</span> strings.ToLower(word) {</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"="</span>:</span><br><span class="line">    	leftWord, rightWord, _ := m.tryFetchBothSideWord(i)</span><br><span class="line">      m.addElement(m.buildPrimitiveMatcher(leftWord, rightWord, <span class="literal">false</span>))</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"=~"</span>:</span><br><span class="line">    	leftWord, rightWord, _ := m.tryFetchBothSideWord(i)</span><br><span class="line">    	m.addElement(m.buildPrimitiveMatcher(leftWord, rightWord, <span class="literal">true</span>))</span><br><span class="line">    <span class="comment">// deal with more cases</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>这部分逻辑比较简单，遇到 <code>=</code> 或者 <code>=~</code> 时看一下前后的词语，看是否能构成原始表达式。</p>
<h3 id="buildmatcher">buildMatcher</h3>
<p><code>buildMatcher</code> 遍历 elements 数组，构建最终的树状复合表达式，其实就是中缀表达式的计算过程，是栈的典型<a href="https://www.geeksforgeeks.org/expression-evaluation/" target="_blank" rel="noopener">应用场景</a>，利用操作符栈和操作数栈即可实现，其整体过程如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  valueStack Stack</span><br><span class="line">	opStack Stack</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, element := <span class="keyword">range</span> m.elements {</span><br><span class="line">  <span class="keyword">switch</span> e := element; {</span><br><span class="line">    <span class="keyword">case</span> e == <span class="string">"("</span>:</span><br><span class="line">      opStack.Push(<span class="string">"("</span>)</span><br><span class="line">    <span class="keyword">case</span> e == <span class="string">")"</span>:</span><br><span class="line">      <span class="keyword">for</span> op := opStack.Pop(); op != <span class="string">"("</span> {</span><br><span class="line">        rhs, lhs := valueStack.Pop(), valueStack.Pop()</span><br><span class="line">        <span class="comment">// apply</span></span><br><span class="line">      }</span><br><span class="line">    <span class="comment">// operators</span></span><br><span class="line">    <span class="keyword">case</span> isOp(e):</span><br><span class="line">      currOp = e</span><br><span class="line">      <span class="keyword">for</span> prevOp := opStack.Peek(); precedence[currOp] &lt;= precedence[prevOp] {</span><br><span class="line">        opStack.Pop()</span><br><span class="line">        rhs, lhs := valueStack.Pop(), valueStack.Pop()</span><br><span class="line">        <span class="comment">// apply prevOp</span></span><br><span class="line">      }</span><br><span class="line">      opStack.Push(currOp)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      valueStack.Push(e)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// deal with the rest valueStack and opStack</span></span><br></pre></td></tr></table></figure>
<h3 id="mcv1-小结">MCV1 小结</h3>
<p>MCV1 是凭借工程师本能构建的一个模块，优势就在于可以迅速地搭建原型，验证想法。从代码健壮性角度看， <code>parseToken</code> 的状态管理比较脆弱；从可读性角度看，无法从逻辑中直接看出其所支持的语法，为后期维护造成障碍；从可扩展性角度看，<code>buildMatcher</code> 目前只支持中缀表达式，如果有语法变化将整体逻辑产生较大影响；从效率角度看，编译一次表达式需要 3 次遍历，如果将 <code>toElements</code> 与 <code>buildMatcher</code> 逻辑合并可以优化到 2 次。</p>
<h2 id="matcher-compiler-v2">Matcher Compiler V2</h2>
<p>为了解决上述问题，我们想到了 Lex 和 Yacc。Lex 是 lexical analyzer generator，能够帮助我们生成词法分析器 (lexical analyzer)；Yacc 是 parser generator，能够帮助我们生成解析器 (parser)，完成语法分析。Lex 和 Yacc 是 Unix 系统的原生工具，Linux 与MacOS 平台也都自带这两个工具。既然已经有前人为我们栽树，我们为什么不趁机乘凉？</p>
<h3 id="lex-yacc">Lex &amp; Yacc</h3>
<p>Lex 和 Yacc 的协作过程如下图所示：</p>
<p><img src="/blog/2020/05/10/The-Evolution-of-Alertmanager-Matcher-in-Palfish/lex-yacc-process.jpg" height="400px"></p>
<p>开发者将构词规则和一些定制化逻辑 (C Code) 定义到 <code>lex.l</code> 文件中，利用 <code>lex</code> 命令生成词法分析器；将语法规则和一些定制化逻辑定义到 <code>parser.y</code> 文件中，利用 <code>yacc</code> 命令生成解析器。词法分析器的 <code>yylex</code> 方法将输入文本转化成 token，投喂给 <code>yyparse</code>，后者根据语法和定制化逻辑将 token 流转化成最终的目标数据结构，即 IR。</p>
<h4 id="examplecalculator">Example：Calculator</h4>
<p>以一个支持加减运算的计算机为例，先定义语法规则：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parser.y</span></span><br><span class="line">%token NUMBER</span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line"><span class="comment">// 括号中的 $$ 表示语法左手边 (LHS) 的值</span></span><br><span class="line"><span class="comment">// 括号中的 $1、$2、$3 表示语法右手边 (RHS) 的值</span></span><br><span class="line">statement: expression   { <span class="built_in">printf</span>(<span class="string">"= %d\n"</span>, $<span class="number">1</span>); }</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">expression: NUMBER <span class="string">'+'</span> NUMBER   { $$ = $<span class="number">1</span> + $<span class="number">3</span>; }</span><br><span class="line">    |       NUMBER <span class="string">'-'</span> NUMBER   { $$ = $<span class="number">1</span> - $<span class="number">3</span>; }</span><br><span class="line">    |       NUMBER              { $$ = $<span class="number">1</span>; }</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>
<p>第一行的 <code>token</code> 定义语法中的数据类型，由于单个字符本身没有歧义，在 Lex 和 Yacc 无需特别定义单字符 token，如 <code>+</code> 和 <code>-</code>，因此在这里我们只需要数字 <code>NUMBER</code>。在第一个 <code>%%</code> 之后，定义了计算器的语法，含义非常直白，可读性强。</p>
<p>然后再定义构词规则：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lex.l</span></span><br><span class="line">%{</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"y.tab.h"</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> yylval;</span><br><span class="line">%}</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line">[<span class="number">0</span><span class="number">-9</span>]+  { yylval = atoi(yytext); <span class="keyword">return</span> NUMBER; }</span><br><span class="line">[ \t] ;</span><br><span class="line">\n <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">. <span class="keyword">return</span> yytext[<span class="number">0</span>];</span><br><span class="line">%%</span><br></pre></td></tr></table></figure>
<p>在两个 <code>%%</code> 中间的就是构词规则：</p>
<ul>
<li>符合正则表达式 <code>[0-9]+</code> 就是数字类型的词语，其对应的值为 <code>atoi(yytext)</code></li>
<li>符合正则表达式 <code>[ \t]</code> 的不处理，即忽略空格和制表符</li>
<li>符合正则表达式 <code>\n</code> 的返回 0，即用换行符标识文本结束位置</li>
<li>符合正则表达式 <code>.</code> 的返回文本本身，即所有非数字的字符直接返回，这里实际上指的就是 <code>+</code> 和 <code>-</code>。</li>
</ul>
<p>接下来只需要用 <code>lex</code> 和 <code>yacc</code> 命令生成词法分析器和解析器，然后运行即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> MacOS</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> lex lex.l</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> yacc -d parser.y</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc y.tab.c lex.yy.c -ly -ll -o calculator</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./calculator</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 128 + 128</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> = 256</span></span><br></pre></td></tr></table></figure>
<h3 id="对比分析">对比分析</h3>
<p>从代码健壮性角度上看，<code>lex</code> 生成的词法分析器已经经受时间的检验，开发者大可相信其代码的健壮性；从可读性角度看，构词规则和语法规则定义简短，通俗易懂；从可扩展性角度看，任何可以通过上下文无关文法 (context-free grammar) 表达的语法都能支持；从效率角度看，<code>yylex</code> 与 <code>yyparse</code> 可以流式地处理文本，<code>yyparse</code> 从 <code>yylex</code> 获取词语，即时地根据语法规则组合成 IR，这种做法使得编译前端的工作只需要 1 次遍历便可完成。但 <code>lex</code> 和 <code>yacc</code> 为了支持更复杂的场景，其生成的代码也会更复杂，这也是效率与通用性权衡的表现。</p>
<h3 id="nex-goyacc">Nex &amp; Goyacc</h3>
<p>报警平台使用 Go 语言编码，直接使用 <code>lex</code> 和 <code>yacc</code> 需要引入 <code>cgo</code>，这也使得二者的使用门槛变高。好在 Go 官方提供了 <code>goyacc</code>，方便我们在 <code>parser.y</code> 中引入用 Go 语言编写的定制化逻辑；斯坦福的一位博士 Ben Lynn 开源了它的 <code>nex</code> 项目，作为用 Go 语言原生开发的词法分析器生成器，能与 <code>goyacc</code> 兼容，形成类似 <code>lex</code> 和 <code>yacc</code> 一般的搭档。接下来我们将利用 <code>nex</code> 和 <code>goyacc</code> 来实现匹配器编译器。</p>
<p>与计算器的例子类似，我们先看语法规则中定义的数据类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">%union{</span><br><span class="line">  str <span class="keyword">string</span></span><br><span class="line">  expr *MatchExpr</span><br><span class="line">  pexpr *PrimitiveExpr</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">%token LABEL VALUE</span><br><span class="line">%token REG_EQ AND OR</span><br><span class="line"></span><br><span class="line">%<span class="keyword">type</span> &lt;expr&gt; expr</span><br><span class="line">%<span class="keyword">type</span> &lt;pexpr&gt; pexpr</span><br><span class="line">%<span class="keyword">type</span> &lt;str&gt; LABEL VALUE</span><br><span class="line">%<span class="keyword">type</span> &lt;str&gt; REG_EQ AND OR</span><br></pre></td></tr></table></figure>
<p>其中，语法中的数据类型包括：</p>
<ul>
<li><code>LABEL</code>：原子表达式的 LHS</li>
<li><code>VALUE</code>：原子表达式的 RHS</li>
<li><code>REG_EQ</code>、<code>AND</code>、<code>OR</code> 分别为正则匹配，且和或</li>
</ul>
<p>此外我们还定义了原始表达式 <code>pexpr</code> 和复合表达式 <code>expr</code> 供定义语法规则时引用。由于语法中有多种关系运算符，它们的优先级不同，因此我们还需要定义运算符的优先级：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%left OR</span><br><span class="line">%left AND</span><br><span class="line">%left <span class="string">'('</span> <span class="string">')'</span></span><br></pre></td></tr></table></figure>
<p><code>left</code> 表示先从运算符的 LHS 开始计算，三者的优先级关系是 <code>OR &lt; AND &lt; '(' == ')'</code>，非常直观。最后进入我们的语法规则：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配器表达式可以是空字符串，也可以是一个合法的表达式</span></span><br><span class="line">matcher:</span><br><span class="line">  { setResult(yylex, &amp;Matcher{}) }</span><br><span class="line">| expr</span><br><span class="line">  { setResult(yylex, $<span class="number">1</span>) }</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表达式可能以下之一：</span></span><br><span class="line"><span class="comment">//   复合表达式：expr AND expr</span></span><br><span class="line"><span class="comment">//   复合表达式：expr OR expr</span></span><br><span class="line"><span class="comment">//   原始表达式：pexpr</span></span><br><span class="line"><span class="comment">//   括号表达式：(expr)</span></span><br><span class="line">expr: expr AND expr</span><br><span class="line">  { $$ = &amp;Matcher{IsCompound: <span class="literal">true</span>, Operator:$<span class="number">2</span>, Operands:[]*Matcher{$<span class="number">1</span>,$<span class="number">3</span>}} }</span><br><span class="line">| expr OR expr</span><br><span class="line">  { $$ = &amp;Matcher{IsCompound: <span class="literal">true</span>, Operator:$<span class="number">2</span>, Operands:[]*Matcher{$<span class="number">1</span>,$<span class="number">3</span>}} }</span><br><span class="line">| pexpr</span><br><span class="line">  { $$ = &amp;Matcher{IsCompound: <span class="literal">false</span>, PrimitiveMatcher:$<span class="number">1</span>} }</span><br><span class="line">| <span class="string">'('</span> expr <span class="string">')'</span></span><br><span class="line">  { $$ = $<span class="number">2</span> }</span><br><span class="line"><span class="comment">// 原始表达式要么是 LABEL = VALUE, 要么是 LABEL =~ VALUE</span></span><br><span class="line">pexpr: LABEL <span class="string">'='</span> VALUE</span><br><span class="line">  { $$ = &amp;PrimitiveMatcher{Label:$<span class="number">1</span>, Text:$<span class="number">3</span>, IsRegex: <span class="literal">false</span>} }</span><br><span class="line">| LABEL REG_EQ VALUE</span><br><span class="line">  { $$ = &amp;PrimitiveMatcher{Label:$<span class="number">1</span>, Text:$<span class="number">3</span>, IsRegex: <span class="literal">true</span>} }</span><br></pre></td></tr></table></figure>
<p>每条语法规则的含义已经标明在注释中，在每条语法规则之后，是 Go 语言编码的简单逻辑，告诉解析器在不同情况下如何拼装 IR。搞定语法后，我们就可以定义构词规则：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/[aA][nN][dD]/                      { lval.str = <span class="string">"AND"</span>; <span class="keyword">return</span> AND }</span><br><span class="line">/[oO][rR]/                          { lval.str = <span class="string">"OR"</span>; <span class="keyword">return</span> OR }</span><br><span class="line">/=~/                                { <span class="keyword">return</span> REG_EQ }</span><br><span class="line">/=/                                 { <span class="keyword">return</span> <span class="keyword">int</span>(yylex.Text()[<span class="number">0</span>]) }</span><br><span class="line">/\(/                                { <span class="keyword">return</span> <span class="keyword">int</span>(yylex.Text()[<span class="number">0</span>]) }</span><br><span class="line">/\)/                                { <span class="keyword">return</span> <span class="keyword">int</span>(yylex.Text()[<span class="number">0</span>]) }</span><br><span class="line">/[A-Za-z][A-Za-z0<span class="number">-9</span>_]*/             { lval.str = yylex.Text(); <span class="keyword">return</span> LABEL }</span><br><span class="line">/<span class="string">".*"</span>/                     { lval.str = yylex.Text()[<span class="number">1</span>:<span class="built_in">len</span>(yylex.Text())<span class="number">-1</span>]; <span class="keyword">return</span> VALUE }</span><br><span class="line">/[ \t\r\n]+/                        { <span class="comment">/* white spaces ignored */</span> }</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">package</span> c</span><br></pre></td></tr></table></figure>
<ul>
<li>大小写无关的字符串 "AND" 返回类型 <code>AND</code>；"OR" 返回类型 <code>OR</code></li>
<li>"=~"、"="、"("、")" 直接返回相应的数据类型</li>
<li>正则表达式 <code>/[A-Za-z][A-Za-z0-9_]*/</code> 匹配的是原始表达式中的 <code>LABEL</code></li>
<li>正则表达式 <code>/".*"/</code> 匹配的是原始表达式中的 <code>VALUE</code></li>
<li>正则表达式 <code>/[ \t\r\n]+/</code> 匹配的是空格字符，即忽略所有类型的空格</li>
</ul>
<p>最后使用 <code>nex</code> 和 <code>goyacc</code> 就可以生成词法分析器和解析器：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nex nex.l</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> goyacc -o parser.go parser.y</span></span><br></pre></td></tr></table></figure>
<p>然后再把二者串起来即可：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 忽略细节处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Compile</span><span class="params">(ctx context.Context, in io.Reader)</span> <span class="params">(m *Matcher, err error)</span></span> {</span><br><span class="line">	lr := NewLexer(in)</span><br><span class="line">	yyParse(lr)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> lr.parseResult == <span class="literal">nil</span> {</span><br><span class="line">		err = SyntaxError</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	m = lr.parseResult.(*Matcher)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="rob-pike-style-lexer">Rob Pike Style Lexer</h3>
<p>完成上面的工作，本可以告一段落，但有一个问题还困扰着我们：”为什么 Go 只推出了 <code>yacc</code> 的移植版本，而不顺便推出 <code>lex</code> 的移植版本？“ 几经周折找到了 Rob Pike 2011 年的一次演讲： "Lexical Scanning in Go"。在演讲中他认为 ” <code>lex</code> 生成的代码太多，过于复杂，用 Go 语言实现一个并非难事，且 Go 的 channel 能方便地实现 <code>lex</code> 和 <code>yacc</code> 的流水线协作。“ 尽管这种观点也是在为 Go 站台，我们还是决定试一试他提出的 lexical scanning 方案。</p>
<p>词法分析的过程，就是从输入字符流起点扫描至终点的线性过程，在扫描期间，词法分析器需要正确地判断自己所处的状态，以起点为例，刚开始扫描，可能进入 <code>LABEL</code> 状态，也可能进入 <code>(</code> 状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">labela = "a" AND (labelb = "b" OR labelc = "c")</span><br><span class="line">↑</span><br><span class="line">在LABEL中</span><br><span class="line"></span><br><span class="line">(labela = "a") OR labelb = "b"</span><br><span class="line">↑</span><br><span class="line">在'('中</span><br></pre></td></tr></table></figure>
<p>扫描完 <code>VALUE</code> 后，可能进入<code>结束</code>状态，也可能进入 <code>)</code> 状态或 <code>关系运算符</code> 状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">labela = "a" AND (labelb = "b" OR labelc = "c")</span><br><span class="line">             ↑</span><br><span class="line">            进入[关系运算符]状态</span><br><span class="line">(labela = "a")</span><br><span class="line">             ↑</span><br><span class="line">            进入 ')' 状态</span><br><span class="line">labela = "a"</span><br><span class="line">            ↑</span><br><span class="line">           进入[结束]状态</span><br></pre></td></tr></table></figure>
<p>不难看出，这实际上就是一个状态机，详细的状态转移过程如下图所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># start: [开始]; leftParen: '('; label: [标签]; eq: [匹配符]; value: [文本];</span><br><span class="line"># rightParen: ')'; binaryOp: [关系运算符]; end: [结束]</span><br><span class="line">                                                +------------+</span><br><span class="line">                                                | rightParen | -------------+</span><br><span class="line">                                                +------------+              |</span><br><span class="line">                                                  ^  |                      |</span><br><span class="line">                                                  |  |                      |</span><br><span class="line">  +----------------------+                        |  ----------------+      |</span><br><span class="line">  |                      v                        |                  v      |</span><br><span class="line">  |  +-----------+     +-------+     +----+     +------------+     +-----+  |</span><br><span class="line">  |  |   start   | --&gt; | label | --&gt; | eq | --&gt; |   value    | --&gt; | end |  |</span><br><span class="line">  |  +-----------+     +-------+     +----+     +------------+     +-----+  |</span><br><span class="line">  |    |                 ^                        |                         |</span><br><span class="line">  |    |                 |                        |                         |</span><br><span class="line">  |    v                 |                        v                         |</span><br><span class="line">  |  +-----------+       |                      +------------+              |</span><br><span class="line">  +- | leftParen |       +--------------------- |  binaryOp  | &lt;------------+</span><br><span class="line">     +-----------+                              +------------+</span><br><span class="line">       ^                                          |</span><br><span class="line">       +------------------------------------------+</span><br></pre></td></tr></table></figure>
<p>接下来就需要让这个状态机动起来：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> lexer <span class="keyword">struct</span> {</span><br><span class="line">  name  <span class="keyword">string</span>    <span class="comment">// used only for error reports.</span></span><br><span class="line">  input <span class="keyword">string</span>    <span class="comment">// the string being scanned.</span></span><br><span class="line">  start <span class="keyword">int</span>       <span class="comment">// start position of this item.</span></span><br><span class="line">  pos   <span class="keyword">int</span>       <span class="comment">// current position in the input.</span></span><br><span class="line">  width <span class="keyword">int</span>       <span class="comment">// width of last rune read from input.</span></span><br><span class="line">  items <span class="keyword">chan</span> item <span class="comment">// channel of scanned items.</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// stateFn represents the state of the scanner</span></span><br><span class="line"><span class="comment">// as a function that returns the next state.</span></span><br><span class="line"><span class="keyword">type</span> stateFn <span class="function"><span class="keyword">func</span><span class="params">(*lexer)</span> <span class="title">stateFn</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *lexer)</span> <span class="title">run</span><span class="params">()</span></span> {</span><br><span class="line">  <span class="keyword">for</span> state := lexStart; state != <span class="literal">nil</span>; {</span><br><span class="line">    state = state(l)</span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">close</span>(l.items)</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>其中 <code>stateFn</code> 就是状态转移方程，约定当 <code>stateFn == nil</code> 时，状态机停止，即 <code>nil</code> 就是结束状态的转移方程。接下来只需要定义各个状态转移方程即可：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lexStart</span><span class="params">(l *lexer)</span> <span class="title">stateFn</span></span> {}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lexLabel</span><span class="params">(l *lexer)</span> <span class="title">stateFn</span></span> {}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lexLeftParen</span><span class="params">(l *lexer)</span> <span class="title">stateFn</span></span> {}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lexRightParen</span><span class="params">(l *lexer)</span> <span class="title">stateFn</span></span> {}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lexEq</span><span class="params">(l *lexer)</span> <span class="title">stateFn</span></span> {}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lexValue</span><span class="params">(l *lexer)</span> <span class="title">stateFn</span></span> {}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lexBinaryOp</span><span class="params">(l *lexer)</span> <span class="title">stateFn</span></span> {}</span><br></pre></td></tr></table></figure>
<p>每当状态即将转移时，<code>stateFn</code> 内部就会将在本状态中扫描到的词语传给 <code>item channel</code>，这个 channel 就是 lexer 与 parser 之间通信的媒介。</p>
<p>值得一提的是，Go 的模板引擎 template，就是按照上述方式构建的，感兴趣可以阅读<a href="https://github.com/golang/go/tree/master/src/text/template/parse/lex.go" target="_blank" rel="noopener">源码</a>。</p>
<h2 id="参考文献">参考文献</h2>
<ul>
<li>Compilers: Principles, Techniques, and Tools, <a href="https://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools" target="_blank" rel="noopener">the dragon book</a></li>
<li>GeeksforGeeks: <a href="https://www.geeksforgeeks.org/expression-evaluation/" target="_blank" rel="noopener">Expression Evaluation Problem</a></li>
<li>Lex &amp; Yacc, <a href="http://dinosaur.compilertools.net/" target="_blank" rel="noopener">website</a>, <a href="http://www.ora.com/catalog/lex/index.html" target="_blank" rel="noopener">book</a></li>
<li>Lexical Scanning in Go by <a href="https://en.wikipedia.org/wiki/Rob_Pike" target="_blank" rel="noopener">Rob Pike</a>, <a href="https://www.youtube.com/watch?v=HxaD_trXwRE" target="_blank" rel="noopener">video</a>, <a href="https://talks.golang.org/2011/lex.slide#1" target="_blank" rel="noopener">slides</a>, <a href="https://blog.golang.org/sydney-gtug" target="_blank" rel="noopener">go blog</a></li>
<li>Go Template, <a href="https://github.com/golang/go/tree/master/src/text/template/parse/lex.go" target="_blank" rel="noopener">source code</a></li>
</ul>
<svg style="display: none" id="MJX-SVG-global-cache"><defs></defs></svg>
    </div>

    
    
    
        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

            <div class="social-item">
              <a target="_blank" class="social-link" href="/blog/atom.xml">
                <span class="icon">
                  <i class="fa fa-rss"></i>
                </span>

                <span class="label">RSS</span>
              </a>
            </div>
    </div>
  </div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/blog/2020/04/05/What-s-Really-New-with-NewSQL-2016/" rel="prev" title="What's Really New with NewSQL (2016)">
      <i class="fa fa-chevron-left"></i> What's Really New with NewSQL (2016)
    </a></div>
      <div class="post-nav-item">
    <a href="/blog/2020/06/07/The-Most-Beautiful-Program-Ever-Written/" rel="next" title="The Most Beautiful Program Ever Written">
      The Most Beautiful Program Ever Written <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#简介"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#背景"><span class="nav-number">1.1.</span> <span class="nav-text">背景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#匹配表达式定义"><span class="nav-number">1.2.</span> <span class="nav-text">匹配表达式定义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编译过程"><span class="nav-number">2.</span> <span class="nav-text">编译过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#matcher-compiler-v1"><span class="nav-number">3.</span> <span class="nav-text">Matcher Compiler V1</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#parsetoken"><span class="nav-number">3.1.</span> <span class="nav-text">parseToken</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#toelements"><span class="nav-number">3.2.</span> <span class="nav-text">toElements</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buildmatcher"><span class="nav-number">3.3.</span> <span class="nav-text">buildMatcher</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mcv1-小结"><span class="nav-number">3.4.</span> <span class="nav-text">MCV1 小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#matcher-compiler-v2"><span class="nav-number">4.</span> <span class="nav-text">Matcher Compiler V2</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#lex-yacc"><span class="nav-number">4.1.</span> <span class="nav-text">Lex &amp; Yacc</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#examplecalculator"><span class="nav-number">4.1.1.</span> <span class="nav-text">Example：Calculator</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对比分析"><span class="nav-number">4.2.</span> <span class="nav-text">对比分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nex-goyacc"><span class="nav-number">4.3.</span> <span class="nav-text">Nex &amp; Goyacc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rob-pike-style-lexer"><span class="nav-number">4.4.</span> <span class="nav-text">Rob Pike Style Lexer</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考文献"><span class="nav-number">5.</span> <span class="nav-text">参考文献</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ZhengHe"
      src="/blog/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">ZhengHe</p>
  <div class="site-description" itemprop="description">郑鹤的博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/ZhengHe-MD" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ZhengHe-MD" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:ranchardzheng@gmail.com" title="E-Mail → mailto:ranchardzheng@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZhengHe</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.1
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/pisces.js"></script>


<script src="/blog/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://zhenghe-hexo-blog.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "https://zhenghe-md.github.io/blog/2020/05/10/The-Evolution-of-Alertmanager-Matcher-in-Palfish/";
    this.page.identifier = "2020/05/10/The-Evolution-of-Alertmanager-Matcher-in-Palfish/";
    this.page.title = "报警平台的匹配器演进";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://zhenghe-hexo-blog.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
