<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zhenghe-md.github.io","root":"/blog/","scheme":"Pisces","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Prometheus 是当下最流行的监控平台之一，它的主要职责是从各个目标节点中采集监控数据，后持久化到本地的时序数据库中，并向外部提供便捷的查询接口。本文尝试探讨 Prometheus 存储层的演进过程，信息源主要来自于 Prometheus 团队在历届 PromConf 上的分享。 时序数据库是 Promtheus 监控平台的一部分，在了解其存储层的演化过程之前，我们需要先了解时序数据库及其要">
<meta property="og:type" content="article">
<meta property="og:title" content="The Evolution of Prometheus Storage Layer">
<meta property="og:url" content="https://zhenghe-md.github.io/2020/02/27/The-Evolution-of-Prometheus-Storage-Layer/index.html">
<meta property="og:site_name" content="ZhengHe">
<meta property="og:description" content="Prometheus 是当下最流行的监控平台之一，它的主要职责是从各个目标节点中采集监控数据，后持久化到本地的时序数据库中，并向外部提供便捷的查询接口。本文尝试探讨 Prometheus 存储层的演进过程，信息源主要来自于 Prometheus 团队在历届 PromConf 上的分享。 时序数据库是 Promtheus 监控平台的一部分，在了解其存储层的演化过程之前，我们需要先了解时序数据库及其要">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zhenghe-md.github.io/blog/2020/02/27/The-Evolution-of-Prometheus-Storage-Layer/ts-sample.jpg">
<meta property="og:image" content="https://zhenghe-md.github.io/blog/2020/02/27/The-Evolution-of-Prometheus-Storage-Layer/tsdb-fundamental-problem.jpg">
<meta property="og:image" content="https://zhenghe-md.github.io/blog/2020/02/27/The-Evolution-of-Prometheus-Storage-Layer/bigtable-ts-schema.jpg">
<meta property="og:image" content="https://zhenghe-md.github.io/blog/2020/02/27/The-Evolution-of-Prometheus-Storage-Layer/iterator.jpg">
<meta property="og:image" content="https://zhenghe-md.github.io/blog/2020/02/27/The-Evolution-of-Prometheus-Storage-Layer/pretty-regular-sample-interval.jpg">
<meta property="og:image" content="https://zhenghe-md.github.io/blog/2020/02/27/The-Evolution-of-Prometheus-Storage-Layer/chunk-encoding.jpg">
<meta property="og:image" content="https://zhenghe-md.github.io/blog/2020/02/27/The-Evolution-of-Prometheus-Storage-Layer/chunk-preloading.jpg">
<meta property="og:image" content="https://zhenghe-md.github.io/blog/2020/02/27/The-Evolution-of-Prometheus-Storage-Layer/checkpoint.jpg">
<meta property="og:image" content="https://zhenghe-md.github.io/blog/2020/02/27/The-Evolution-of-Prometheus-Storage-Layer/partition.jpg">
<meta property="og:image" content="https://zhenghe-md.github.io/blog/2020/02/27/The-Evolution-of-Prometheus-Storage-Layer/many-little-databases.jpg">
<meta property="og:image" content="https://zhenghe-md.github.io/blog/2020/02/27/The-Evolution-of-Prometheus-Storage-Layer/compaction.jpg">
<meta property="og:image" content="https://zhenghe-md.github.io/blog/2020/02/27/The-Evolution-of-Prometheus-Storage-Layer/retention.jpg">
<meta property="article:published_time" content="2020-02-27T09:50:01.000Z">
<meta property="article:modified_time" content="2020-03-26T03:57:39.332Z">
<meta property="article:author" content="ZhengHe">
<meta property="article:tag" content="tsdb">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhenghe-md.github.io/blog/2020/02/27/The-Evolution-of-Prometheus-Storage-Layer/ts-sample.jpg">

<link rel="canonical" href="https://zhenghe-md.github.io/2020/02/27/The-Evolution-of-Prometheus-Storage-Layer/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>The Evolution of Prometheus Storage Layer | ZhengHe</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"] > svg a {
  fill: blue;
  stroke: blue;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container {
  overflow: auto hidden;
}

mjx-container + br {
  display: none;
}
</style><link rel="alternate" href="/blog/atom.xml" title="ZhengHe" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ZhengHe</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right"></div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/blog/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhenghe-md.github.io/2020/02/27/The-Evolution-of-Prometheus-Storage-Layer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpeg">
      <meta itemprop="name" content="ZhengHe">
      <meta itemprop="description" content="郑鹤的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhengHe">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          The Evolution of Prometheus Storage Layer
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-27 09:50:01" itemprop="dateCreated datePublished" datetime="2020-02-27T09:50:01+00:00">2020-02-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-26 03:57:39" itemprop="dateModified" datetime="2020-03-26T03:57:39+00:00">2020-03-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/system-design/" itemprop="url" rel="index">
                    <span itemprop="name">system design</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2020/02/27/The-Evolution-of-Prometheus-Storage-Layer/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/02/27/The-Evolution-of-Prometheus-Storage-Layer/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Prometheus 是当下最流行的监控平台之一，它的主要职责是从各个目标节点中采集监控数据，后持久化到本地的时序数据库中，并向外部提供便捷的查询接口。本文尝试探讨 Prometheus 存储层的演进过程，信息源主要来自于 Prometheus 团队在历届 PromConf 上的分享。</p>
<p>时序数据库是 Promtheus 监控平台的一部分，在了解其存储层的演化过程之前，我们需要先了解时序数据库及其要解决的根本问题。</p>
<h1 id="tsdb">TSDB</h1>
<p><strong>时序数据库 (Time Series Database, TSDB)</strong> 是数据库大家庭中的一员，专门存储随时间变化的数据，如股票价格、传感器数据、机器状态监控等等。<strong>时序 (Time Series)</strong> 指的是某个变量随时间变化的所有历史，而<strong>样本 (Sample)</strong> 指的是历史中该变量的瞬时值：</p>
<p><img src="/blog/2020/02/27/The-Evolution-of-Prometheus-Storage-Layer/ts-sample.jpg" width="500px"></p>
<p>每个样本由<strong>时序标识</strong>、<strong>时间戳</strong>和<strong>数值</strong> 3 部分构成，其所属的时序就由一系列样本构成。由于时间是连续的，我们不可能、也没有必要记录时序在每个时刻的数值，因此<strong>采样间隔</strong> (Interval) 也是时序的重要组成部分。采样间隔越小、样本总量越大、捕获细节越多；采样间隔越大、样本总量越小、遗漏细节越多。以服务器机器监控为例，通常采样间隔为 15 秒。</p>
<p>数据的高效查询离不开索引，对于时序数据而言，唯一的、天然的索引就是时间 (戳)。因此通常时序数据库的存储层相比于关系型数据库要简单得多。仔细思考，你可能会发现时序数据在某种程度上就是键值数据的一个子集，因此键值数据库天然地可以作为时序数据的载体。通常一个时序数据库能容纳百万量级以上的时序数据，要从其中搜索到其中少量的几个时序也非易事，因此对时序本身建立高效的索引也很重要。</p>
<h1 id="the-fundamental-problem-of-tsdbs">The Fundamental Problem of TSDBs</h1>
<p>TSDB 要解决的基本问题，可以概括为下图：</p>
<p><img src="/blog/2020/02/27/The-Evolution-of-Prometheus-Storage-Layer/tsdb-fundamental-problem.jpg" width="500px"></p>
<p>在 <a href="/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/">Log Structured Merge (LSM) Tree &amp; Usages in KV Stores</a> 一文中，我曾提到过：</p>
<blockquote>
<p>许多数据库的奇技淫巧都是在解决内存与磁盘的读写模式、性能的不匹配问题</p>
</blockquote>
<p>时序数据库也是数据库的一种，只要它想持久化，自然不能例外。但与键值数据库相比，时序数据库存储的数据有更特殊的读写特征，Björn Rabenstein 将称其为：</p>
<blockquote>
<p>Vertical writes, horizontal(-ish) reads</p>
<blockquote>
<p>垂直写，水平读</p>
</blockquote>
</blockquote>
<p>图中每条横线就是一个时序，每个时序由按照 (准) 固定间隔采集的样本数据构成，通常在时序数据库中会有很多活跃时序，因此数据写入可以用一个垂直的窄方框表示，即每个时序都要写入新的样本数据；用户在查询时，通常会观察某个、某几个时序在某个时间段内的变化趋势，或对其进行聚合计算，因此数据读取可以用一个水平的方框表示。是谓 "垂直写、水平读"。</p>
<h1 id="storage-layer-of-prometheus">Storage Layer of Prometheus</h1>
<p>Prometheus 是为云原生环境中的数据监控而生，在其设计过程中至少需要考虑以下两个方面：</p>
<ol type="1">
<li>在云原生环境中，实例可能随时出现、消失，因此时序也可能随时出现或消失，即系统中存在大量时序，其中部分处于活跃状态，这会在多方面带来挑战：
<ul>
<li>如何存储大量时序避免资源浪费</li>
<li>如何定位被查询的少数几个时序</li>
</ul></li>
<li>监控系统本身应该尽量少地依赖外部服务，否则外部服务失效将引发监控系统失效</li>
</ol>
<p>对于第 2 点，Prometheus 团队选择放弃集群，使用单机架构，并且在单机系统中使用本地 TSDB 做数据持久化，完全不依赖外部服务；第 1 点是需要存储、索引、查询引擎层合作解决的问题，在下文中我们将进一步分析存储层在其中的作用。Prometheus 存储层的演进可以分成 3 个阶段：</p>
<ul>
<li>1st Generation: Prototype</li>
<li>2nd Generation: Prometheus V1</li>
<li>3rd Generation: Prometheus V2</li>
</ul>
<p><em>注意：本节只关注 Prometheus 时序数据的存储，不涉及索引、WAL 等其它数据的存储。</em></p>
<h2 id="data-model">Data Model</h2>
<p>尽管数据模型是存储层之上的抽象，理论上它不应该影响存储层的设计。但理解数据模型能够帮助我们更快地理解存储层。</p>
<p>在 Prometheus 中，每个时序实际上由多个<strong>标签</strong> (labels) 标识，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api_http_requests_total&#123;path&#x3D;&quot;&#x2F;users&quot;,status&#x3D;200,method&#x3D;&quot;GET&quot;,instance&#x3D;&quot;10.111.201.26&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>该时序的名字为 api_http_requests_total，标签为 path、status、method 和 instance，只有时序名字和标签键值完全相同的时序才是同一个时序。事实上，时序名字就是一个隐藏标签：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;__name__&#x3D;&quot;api_http_requests_total&quot;,path&#x3D;&quot;&#x2F;users&quot;,status&#x3D;200,method&#x3D;&quot;GET&quot;,instance&#x3D;&quot;10.111.201.26&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>对于用户来说，标签之间不存在先后顺序，用户可能关注：</p>
<ul>
<li>所有 api 调用的 status</li>
<li>某个 path 调用的成功率、QPS</li>
<li>某个实例、某个 path 调用的成功率</li>
<li>...</li>
</ul>
<h2 id="st-generation-prototype">1st Generation: Prototype</h2>
<p>在 Prototype 阶段，Prometheus 直接利用开源的键值数据库 (LevelDB) 作为本地持久化存储，并采用与 <a href="https://cloud.google.com/bigtable/docs/schema-design-time-series?hl=en#server_metrics" target="_blank" rel="noopener">BigTable 推荐的时序数据方案</a> 类似的 schema 设计：</p>
<p><img src="/blog/2020/02/27/The-Evolution-of-Prometheus-Storage-Layer/bigtable-ts-schema.jpg" width="600px"></p>
<p>将<strong>时序名称、标签 (固定顺序)、时间戳</strong>拼接成每个样本的键，于是同一个时序的数据就能够连续存储在键值数据库中，提高范围查询的效率。但从图中可以看出，这种方式存储的键很长，尽管键值数据库内部会对数据进行压缩，但是在内存中这样存储数据很浪费空间，这无法满足项目的设计要求。Prometheus 希望在内存中压缩数据，使得内存中可以容纳更多活跃的时序数据，同时在磁盘中也能按类似的方式压缩编码，提高效率。时序数据比通用键值数据有更显著的特征。即使键值数据库能够压缩数据，但针对时序数据的特征，使用特殊的压缩算法能够取得更好的压缩率。因此在 Prototype 阶段，使用三方键值数据库的方案最终流产。</p>
<h2 id="nd-generation-prometheus-v1">2nd Generation: Prometheus V1</h2>
<h3 id="compression">Compression</h3>
<h5 id="why-compression">Why Compression?</h5>
<p>假设监控系统的需求如下：</p>
<ul>
<li>500 万活跃时序</li>
<li>30 秒采样间隔</li>
<li>1 个月数据留存</li>
</ul>
<p>那么经过计算可以得到具体的存储要求：</p>
<ul>
<li>平均每秒采集 166000 个样本</li>
<li>存储样本总量为 4320 亿个样本</li>
</ul>
<p>假设没有任何压缩，不算时序标识，每个样本需要 16 个字节存储空间 (时间戳 8 个字节、数值 8 个字节)，整个系统的<strong>存储总量为 7TB</strong>，假设数据需要留存 6 个月，则<strong>总量为 42 TB</strong>，那么如果能找到一种有效的方式压缩数据，就能在单机的内存和磁盘中存放更多、更长的时序数据。</p>
<h5 id="chunked-storage-abstraction">Chunked Storage Abstraction</h5>
<p>上文提到 TSDB 的根本问题是 "垂直写，水平读"，每次采样都会需要为每个活跃时序写入一条样本数据，但如果每次为每个时序写入 16 个字节到 HDD/SSD 中，显然这对块存储设备十分不友好，效率低下。因此 Prometheus V2 将数据按固定长度切割相同大小的分段 (Chunks)，方便压缩、批量读写。</p>
<p>访问时序数据时，Prometheus 使用 3 层抽象，如下图所示：</p>
<p><img src="/blog/2020/02/27/The-Evolution-of-Prometheus-Storage-Layer/iterator.jpg" width="600px"></p>
<p>应用层使用 Series Iterator 顺序访问时序中的样本，而 Series Iterator 底下由一个个 Chunk Iterator 拼接而成，每个 Chunk Iterator 负责将压缩编码的时序数据解码返回。这样做的好处是，<strong>每个 Chunk 甚至可以使用完全不同的方式编码</strong>，方便开发团队尝试不同的编码方案。</p>
<h5 id="timestamp-compression-double-delta">Timestamp Compression: Double Delta</h5>
<p>由于通常数据采样间隔是固定值，因此前后时间戳的差值几乎固定，如 15s，30s。但如果我们更近一步，只存储差值的差值，那么几乎不用再为新的时间戳花费额外的空间，这便是所谓的 "<strong>Double Delta</strong>"。本质上，如果未来所有的采集时间戳都可以精准预测，那么每个新时间戳的信息熵为 0 bit。但现实并不完美，网络可能延迟、中断，实例可能遇到 GC、重启，采样间隔随时有可能波动：</p>
<p><img src="/blog/2020/02/27/The-Evolution-of-Prometheus-Storage-Layer/pretty-regular-sample-interval.jpg" width="500px"></p>
<p>但这种波动的幅度有限，Prometheus 采用了和 FB 的内存时序数据库 Gorilla 类似的方式编码时间戳，详情可以参考我的另一篇博客 <a href="(/blog/2020/02/16/Gorilla-A-Fast-Scalable-In-Memory-Time-Series-Database-2015/)">Gorilla</a> 以及 Björn Rabenstein 在 PromConn 2016 的演讲 <a href="https://docs.google.com/presentation/d/1TMvzwdaS8Vw9MtscI9ehDyiMngII8iB_Z5D4QW4U4ho/edit#slide=id.g15afea0287_0_16" target="_blank" rel="noopener">ppt</a> ，细节比较琐碎，这里不赘述。</p>
<h5 id="value-compression">Value Compression</h5>
<p>Prometheus 和 Gorilla 中的每个样本值都是 float64 类型。Gorilla 利用 float64 的二进制表示 (IEEE754) 将前后两个样本值 XOR 来寻找压缩的空间，能获得 1.37 bytes/sample 的压缩能力。Prometheus V2 采用的方式比较简单：</p>
<ul>
<li>如果可能的话，使用整型 (8/16/32 位) 存储，否则用 float32，最后实在不行就直接存储 float64</li>
<li>如果数值增长得很规律，则不使用额外的空间存储</li>
</ul>
<p>以上做法给 Prometheus V1 带来了 3.3 bytes/sample 的压缩能力。相比于为完全存储于内存中的 Gorilla 相比，这样的压缩能力对于 Prometheus 已经够用，但在 V2 中，Prometheus 也融合了 Gorilla 采用的压缩技术。</p>
<h3 id="chunk-encoding">Chunk Encoding</h3>
<p>Prometheus V1 将每个时序分割成大小为 1KB 的 chunks，如下图所示：</p>
<p><img src="/blog/2020/02/27/The-Evolution-of-Prometheus-Storage-Layer/chunk-encoding.jpg" width="600px"></p>
<p>在内存中保留着最近写入的 chunk，其中 head chunk 正在接收新的样本。每当一个 head chunk 写满 1KB 时，会立即被冻结，我们称之为完整的 chunk，从此刻开始该 chunk 中的数据就是不可变的 (immutable) ，同时生成一个新的 head chunk 负责消化新的请求。每个完整的 chunk 会被尽快地持久化到磁盘中。内存中保存着每个时序最近被写入或被访问的 chunks，当 chunks 数量过多时，存储引擎会将超过的 chunks 通过 LRU 策略清出。</p>
<p>在 Prometheus V1 中，每个时序都会被存储到在一个独占的文件中，这也意味着大量的时序将产生大量的文件。存储引擎会定期地去检查磁盘中的时序文件，是否已经有 chunk 数据超过保留时间，如果有则将其删除 (复制后删除)。</p>
<p>Prometheus 的查询引擎的查询过程必须完全在内存中进行。因此在执行之前，存储引擎需要将不在内存中的 chunks 预加载到内存中：</p>
<p><img src="/blog/2020/02/27/The-Evolution-of-Prometheus-Storage-Layer/chunk-preloading.jpg" width="600px"></p>
<p>如果在内存中的 chunks 持久化之前系统发生崩溃，则会产生数据丢失。为了减少数据丢失，Prometheus V1 还使用了额外的 checkpoint 文件，用于存储各个时序中尚未写入磁盘的 chunks：</p>
<p><img src="/blog/2020/02/27/The-Evolution-of-Prometheus-Storage-Layer/checkpoint.jpg" width="600px"></p>
<h3 id="prometheus-v1-vs.-gorilla">Prometheus V1 vs. Gorilla</h3>
<p>正因为 Prometheus V1 与 Gorilla 的设计理念、需求有所不同，我们可以通过对比二者来理解其设计过程中使用不同决策的原因。</p>
<table>
<colgroup>
<col style="width: 12%" />
<col style="width: 43%" />
<col style="width: 43%" />
</colgroup>
<thead>
<tr class="header">
<th>Features/Settings</th>
<th>Prometheus V1</th>
<th>Gorilla</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Storage</td>
<td>Demultiplexing to local disk<br />尽量单机、无依赖、支持大量时序存储</td>
<td>In-memory only<br />为了查询快，必须全部在内存，可以分片</td>
</tr>
<tr class="even">
<td>Resolution</td>
<td>1ms</td>
<td>1s</td>
</tr>
<tr class="odd">
<td>Chunks</td>
<td>Fixed-size chunks (1KB)<br />优化 I/O</td>
<td>Fixed-time blocks (2h)<br />优化 I/O，同时方便检索 blocks</td>
</tr>
<tr class="even">
<td>Decoding</td>
<td>Random accessibility &amp; decoding<br />希望用户不用关心编解码<br />直接通过 HTTP API 获取易于理解的数据</td>
<td>Not concerned with decoding<br />为了查询快，减少网络延迟，在客户端解码</td>
</tr>
<tr class="odd">
<td>Compression</td>
<td>3.3 bytes/sample<br />够用的压缩率</td>
<td>1.37 bytes/sample<br />极致的压缩率，内存更昂贵</td>
</tr>
</tbody>
</table>
<h2 id="rd-generation-prometheus-v2">3rd Generation: Prometheus V2</h2>
<h3 id="the-main-problem-with-2nd-generation">The Main Problem With 2nd Generation</h3>
<p>Prometheus V1 中，每个时序数据对应一个磁盘文件的方式给系统带来了比较大的麻烦：</p>
<ul>
<li>由于在云原生环境下，会不断产生新的时序、废弃旧的时序 (Series Churn)，因此实际上存储层需要的文件数量远远高于活跃的时序数量。任其发展迟早会将文件系统的 inodes 消耗殆尽。而且一旦发生，恢复系统将异常麻烦。不仅如此，在新旧时序大量更迭时，由于旧时序数据尚未从内存中清出，系统的内存消耗量也会飙升，造成 OOM。</li>
<li>即便使用 chunks 来批量读写数据，从整体上看，系统每秒钟仍要向磁盘写入数千个 chunks，造成 I/O 压力；如果通过增大每批写入的量来减少 I/O 次数，又将造成内存的压力。</li>
<li>同时将所有时序文件保持打开状态很不合理，需要消耗大量的资源。如果在查询前后打开、关闭文件，又会增加查询的时延。</li>
<li>当数据超过留存时间时需要删除相关的 chunks，这意味着每隔一段时间就要对数百万的文件执行一次删除数据操作，这个过程可能需要持续数小时。</li>
<li>通过周期性地将未持久化的 chunks 写入 checkpoint 文件理论上确实可以减少数据丢失，但是如果执行数据恢复需要很长时间，那么实际上又错过了新的数据，还不如不恢复。</li>
</ul>
<p>因此 Prometheus 的第三代存储引擎，主要改变就是放弃 "一个时序对应一个文件" 的设计理念。</p>
<h3 id="macro-design">Macro Design</h3>
<p>第三代存储引擎在磁盘中的文件结构如下图所示：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ tree ./data</span><br><span class="line">./data</span><br><span class="line">├── b-000001</span><br><span class="line">│   ├── chunks</span><br><span class="line">│   │   ├── 000001</span><br><span class="line">│   │   ├── 000002</span><br><span class="line">│   │   └── 000003</span><br><span class="line">│   ├── index</span><br><span class="line">│   └── meta.json</span><br><span class="line">├── b-000004</span><br><span class="line">│   ├── chunks</span><br><span class="line">│   │   └── 000001</span><br><span class="line">│   ├── index</span><br><span class="line">│   └── meta.json</span><br><span class="line">├── b-000005</span><br><span class="line">│   ├── chunks</span><br><span class="line">│   │   └── 000001</span><br><span class="line">│   ├── index</span><br><span class="line">│   └── meta.json</span><br><span class="line">└── b-000006</span><br><span class="line">    ├── meta.json</span><br><span class="line">    └── wal</span><br><span class="line">        ├── 000001</span><br><span class="line">        ├── 000002</span><br><span class="line">        └── 000003</span><br></pre></td></tr></table></figure>
<p>根目录下，顺序排列着编了号的 blocks，每个 block 中包含 index 和 chunk 文件夹，后者里面包含编了号的 chunks，每个 chunk 包含<strong>许多不同时序的样本数据</strong>。其中 index 文件中的信息可以帮我我们快速锁定时序的标签及其可能的取值，进而找到相关的时序和持有该时序样本数据的 chunks。值得注意的是，最新的 block 文件夹中还包含一个 wal 文件夹，后者将承担故障恢复的职责。</p>
<h3 id="many-little-databases">Many Little Databases</h3>
<p>第三代存储引擎将所有时序数据按时间分片，即在时间维度上将数据划分成互不重叠的 blocks，如下图所示：</p>
<p><img src="/blog/2020/02/27/The-Evolution-of-Prometheus-Storage-Layer/partition.jpg" width="600px"></p>
<p>每个 block 实际上就是一个小型数据库，内部存储着该时间窗口内的所有时序数据，因此它需要拥有自己的 index 和 chunks。除了最新的、正在接收新鲜数据的 block 之外，其它 blocks 都是不可变的。由于新数据的写入都在内存中，数据的写效率较高：</p>
<p><img src="/blog/2020/02/27/The-Evolution-of-Prometheus-Storage-Layer/many-little-databases.jpg" width="600px"></p>
<p>为了防止数据丢失，所有新采集的数据都会被写入到 WAL 日志中，在系统恢复时能快速地将其中的数据恢复到内存中。在查询时，我们需要将查询发送到不同的 block 中，再将结果聚合。</p>
<p>按时间将数据分片赋予了存储引擎新的能力：</p>
<ul>
<li>当查询某个时间范围内的数据，我们可以直接忽略在时间范围外的 blocks</li>
<li>写完一个 block 后，我们可以将轻易地其持久化到磁盘中，因为只涉及到少量几个文件的写入</li>
<li>新的数据，也是最常被查询的数据会处在内存中，提高查询效率 (第二代同样支持)</li>
<li>每个 chunk 不再是固定的 1KB 大小，我们可以选择任意合适的大小，选择合适的压缩方式</li>
<li>删除超过留存时间的数据变得异常简单，直接删除整个文件夹即可</li>
</ul>
<h3 id="mmap">mmap</h3>
<p>第三代引擎将数百万的小文件合并成少量大文件，也让 mmap 成为可能。利用 mmap 将文件 I/O 、缓存管理交给操作系统，降低 OOM 发生的频率。</p>
<h3 id="compaction">Compaction</h3>
<p>在 Macro Design 中，我们将所有时序数据按时间切割成许多 blocks，当新写满的 block 持久化到磁盘后，相应的 WAL 文件也会被清除。写入数据时，我们希望每个 block 不要太大，比如 2 小时左右，来避免在内存中积累过多的数据。读取数据时，若查询涉及到多个时间段，就需要对许多个 block 分别执行查询，然后再合并结果。假如需要查询一周的数据，那么这个查询将涉及到 80 多个 blocks，降低数据读取的效率。</p>
<p>为了既能写得快，又能读得快，我们就得引入 compaction，后者将一个或多个 blocks 中的数据合并成一个更大的 block，在合并的过程中会自动丢弃被删除的数据、合并多个版本的数据、重新结构化 chunks 来优化查询效率，如下图所示：</p>
<p><img src="/blog/2020/02/27/The-Evolution-of-Prometheus-Storage-Layer/compaction.jpg" width="600px"></p>
<h3 id="retention">Retention</h3>
<p>当数据超过留存时间时，删除旧数据非常容易：</p>
<p><img src="/blog/2020/02/27/The-Evolution-of-Prometheus-Storage-Layer/retention.jpg" width="600px"></p>
<p>直接删除在边界之外的 block 文件夹即可。如果边界在某个 block 之内，则暂时将它留存，知道边界超出为止。当然，在 Compaction 中，我们会将旧的 blocks 合并成更大的 block；在 Retention 时，我们又希望能够粒度更小。所以 Compaction 与 Retention 的策略之间存在着一定的互斥关系。Prometheus 的系统参数可以对单个 block 的大小作出限制，来寻找二者之间的平衡。</p>
<p>看到这里，相信你已经发现了，<strong>这不就是 <a href="/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/">LSM Tree</a> 吗？</strong>每个 block 就是按时间排序的 SSTable，内存中的 block 就是 MemTable。</p>
<h3 id="compression-1">Compression</h3>
<p>第三代存储引擎融合了 Gorilla 的 XOR float encoding 方案，将压缩能力提升到 1-2 bytes/sample。具体方案可以概括为：按顺序采用以下第一条适用的策略</p>
<ol type="1">
<li>Zero encoding：如果完全可预测，则无需额外空间</li>
<li>Integer double-delta encoding：如果是整型，可以利用 double-delta 原理，将不等的前后间隔分成 6/13/20/33 bits 几种，来优化空间使用</li>
<li>XOR float encoding：参考 <a href="/blog/2020/02/16/Gorilla-A-Fast-Scalable-In-Memory-Time-Series-Database-2015/">Gorilla</a></li>
<li>Direct encoding：直接存 float64</li>
</ol>
<p>平均下来能取得 1.28 bytes/sample 的压缩能力。</p>
<h1 id="references">References</h1>
<ul>
<li><a href="https://www.youtube.com/watch?v=b_pEevMAC3I&amp;feature=youtu.be" target="_blank" rel="noopener">PromCon 2017: Storing 16 Bytes at Scale - Fabian Reinartz</a>, <a href="https://promcon.io/2017-munich/slides/storing-16-bytes-at-scale.pdf" target="_blank" rel="noopener">slides</a></li>
<li><a href="https://fabxc.org/tsdb/" target="_blank" rel="noopener">Writing a Time Series Database from Scratch</a></li>
<li><a href="https://www.youtube.com/watch?v=HbnGSNEjhUc" target="_blank" rel="noopener">PromCon 2016: The Prometheus Time Series Database - Björn Rabenstein</a>, <a href="https://docs.google.com/presentation/d/1TMvzwdaS8Vw9MtscI9ehDyiMngII8iB_Z5D4QW4U4ho/edit#slide=id.g59e2f6081_1_0" target="_blank" rel="noopener">slides</a></li>
<li><a href="https://www.youtube.com/watch?v=evPYwNzoltU&amp;t=782s" target="_blank" rel="noopener">Percona Live Open Source Database Conference 2017: Life of a PromQL query</a></li>
<li><a href="https://prometheus.io/docs/prometheus/1.8/storage/" target="_blank" rel="noopener">Prometheus 1.8 doc: storage</a></li>
<li><a href="https://prometheus.io/docs/prometheus/latest/storage/" target="_blank" rel="noopener">Prometheus 2.16 doc: storage</a></li>
<li><a href="https://cloud.google.com/bigtable/docs/schema-design-time-series?hl=en#server_metrics" target="_blank" rel="noopener">Google Cloud: Schema Design for Time Series Data</a></li>
</ul>

    </div>

    
    
    
        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

            <div class="social-item">
              <a target="_blank" class="social-link" href="/blog/atom.xml">
                <span class="icon">
                  <i class="fa fa-rss"></i>
                </span>

                <span class="label">RSS</span>
              </a>
            </div>
    </div>
  </div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/blog/tags/tsdb/" rel="tag"># tsdb</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/" rel="prev" title="Log Structured Merge (LSM) Tree & Usages in KV Stores">
      <i class="fa fa-chevron-left"></i> Log Structured Merge (LSM) Tree & Usages in KV Stores
    </a></div>
      <div class="post-nav-item">
    <a href="/blog/2020/03/08/Scaling-Memcache-at-Facebook-2013/" rel="next" title="Scaling Memcache at Facebook (2013)">
      Scaling Memcache at Facebook (2013) <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#tsdb"><span class="nav-number">1.</span> <span class="nav-text">TSDB</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#the-fundamental-problem-of-tsdbs"><span class="nav-number">2.</span> <span class="nav-text">The Fundamental Problem of TSDBs</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#storage-layer-of-prometheus"><span class="nav-number">3.</span> <span class="nav-text">Storage Layer of Prometheus</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#data-model"><span class="nav-number">3.1.</span> <span class="nav-text">Data Model</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#st-generation-prototype"><span class="nav-number">3.2.</span> <span class="nav-text">1st Generation: Prototype</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#nd-generation-prometheus-v1"><span class="nav-number">3.3.</span> <span class="nav-text">2nd Generation: Prometheus V1</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#compression"><span class="nav-number">3.3.1.</span> <span class="nav-text">Compression</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#why-compression"><span class="nav-number">3.3.1.0.1.</span> <span class="nav-text">Why Compression?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#chunked-storage-abstraction"><span class="nav-number">3.3.1.0.2.</span> <span class="nav-text">Chunked Storage Abstraction</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#timestamp-compression-double-delta"><span class="nav-number">3.3.1.0.3.</span> <span class="nav-text">Timestamp Compression: Double Delta</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#value-compression"><span class="nav-number">3.3.1.0.4.</span> <span class="nav-text">Value Compression</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#chunk-encoding"><span class="nav-number">3.3.2.</span> <span class="nav-text">Chunk Encoding</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#prometheus-v1-vs.-gorilla"><span class="nav-number">3.3.3.</span> <span class="nav-text">Prometheus V1 vs. Gorilla</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rd-generation-prometheus-v2"><span class="nav-number">3.4.</span> <span class="nav-text">3rd Generation: Prometheus V2</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#the-main-problem-with-2nd-generation"><span class="nav-number">3.4.1.</span> <span class="nav-text">The Main Problem With 2nd Generation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#macro-design"><span class="nav-number">3.4.2.</span> <span class="nav-text">Macro Design</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#many-little-databases"><span class="nav-number">3.4.3.</span> <span class="nav-text">Many Little Databases</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mmap"><span class="nav-number">3.4.4.</span> <span class="nav-text">mmap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#compaction"><span class="nav-number">3.4.5.</span> <span class="nav-text">Compaction</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#retention"><span class="nav-number">3.4.6.</span> <span class="nav-text">Retention</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#compression-1"><span class="nav-number">3.4.7.</span> <span class="nav-text">Compression</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#references"><span class="nav-number">4.</span> <span class="nav-text">References</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ZhengHe"
      src="/blog/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">ZhengHe</p>
  <div class="site-description" itemprop="description">郑鹤的博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/ZhengHe-MD" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ZhengHe-MD" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:ranchardzheng@gmail.com" title="E-Mail → mailto:ranchardzheng@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZhengHe</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/pisces.js"></script>


<script src="/blog/js/next-boot.js"></script>




  















  

  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://zhenghe-hexo-blog.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "https://zhenghe-md.github.io/2020/02/27/The-Evolution-of-Prometheus-Storage-Layer/";
    this.page.identifier = "2020/02/27/The-Evolution-of-Prometheus-Storage-Layer/";
    this.page.title = "The Evolution of Prometheus Storage Layer";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://zhenghe-hexo-blog.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
