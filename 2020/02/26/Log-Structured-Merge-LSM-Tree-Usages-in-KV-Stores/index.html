<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zhenghe-md.github.io","root":"/blog/","images":"/blog/images","scheme":"Mist","darkmode":false,"version":"8.9.0","exturl":false,"sidebar":{"position":"left","display":"remove","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/blog/js/config.js"></script>
<meta name="description" content="Background 数据库中的各种奇技淫巧，实际上都来自于内存与磁盘的读写模式和性能区别。   总结如下表：    Memory Disk     byte-addressable block-addressable   fast slow   expensive cheap    当数据库中的数据无法一次性装入内存时，数据的读写就可能需要从内存穿透到磁盘。在 OLTP 场景下，每次事务写入和读">
<meta property="og:type" content="article">
<meta property="og:title" content="用 LSM Tree 实现一个键值数据库 —— GopherConf 2017 演讲笔记">
<meta property="og:url" content="https://zhenghe-md.github.io/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/index.html">
<meta property="og:site_name" content="ZhengHe">
<meta property="og:description" content="Background 数据库中的各种奇技淫巧，实际上都来自于内存与磁盘的读写模式和性能区别。   总结如下表：    Memory Disk     byte-addressable block-addressable   fast slow   expensive cheap    当数据库中的数据无法一次性装入内存时，数据的读写就可能需要从内存穿透到磁盘。在 OLTP 场景下，每次事务写入和读">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zhenghe-md.github.io/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/memory-disk.jpg">
<meta property="og:image" content="https://zhenghe-md.github.io/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/file-block.jpg">
<meta property="og:image" content="https://zhenghe-md.github.io/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/b+tree.jpg">
<meta property="og:image" content="https://zhenghe-md.github.io/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/lsm-tree.jpg">
<meta property="og:image" content="https://zhenghe-md.github.io/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/lsm-tree-with-bloom-filters.jpg">
<meta property="og:image" content="https://zhenghe-md.github.io/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/tiering-leveling.jpg">
<meta property="og:image" content="https://zhenghe-md.github.io/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/tiering-leveling-2.jpg">
<meta property="og:image" content="https://zhenghe-md.github.io/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/tiering-leveling-curve.jpg">
<meta property="og:image" content="https://zhenghe-md.github.io/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/tiering-leveling-curve-with-products.jpg">
<meta property="og:image" content="https://zhenghe-md.github.io/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/moss-kv.jpg">
<meta property="og:image" content="https://zhenghe-md.github.io/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/moss-requirements.jpg">
<meta property="og:image" content="https://zhenghe-md.github.io/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/moss-basic-idea-1.jpg">
<meta property="og:image" content="https://zhenghe-md.github.io/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/moss-basic-idea-2.jpg">
<meta property="og:image" content="https://zhenghe-md.github.io/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/moss-basic-idea-3.jpg">
<meta property="og:image" content="https://zhenghe-md.github.io/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/moss-data-layout-1.jpg">
<meta property="og:image" content="https://zhenghe-md.github.io/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/moss-data-layout-2.jpg">
<meta property="og:image" content="https://zhenghe-md.github.io/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/moss-data-layout-3.jpg">
<meta property="og:image" content="https://zhenghe-md.github.io/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/moss-data-layout-4.jpg">
<meta property="og:image" content="https://zhenghe-md.github.io/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/moss-iteration.jpg">
<meta property="og:image" content="https://zhenghe-md.github.io/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/moss-background-merger-1.jpg">
<meta property="og:image" content="https://zhenghe-md.github.io/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/moss-background-merger-2.jpg">
<meta property="og:image" content="https://zhenghe-md.github.io/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/moss-database-file-1.jpg">
<meta property="og:image" content="https://zhenghe-md.github.io/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/moss-database-file-2.jpg">
<meta property="og:image" content="https://zhenghe-md.github.io/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/moss-database-file-3.jpg">
<meta property="article:published_time" content="2020-02-26T23:23:03.000Z">
<meta property="article:modified_time" content="2024-10-10T14:53:27.106Z">
<meta property="article:author" content="ZhengHe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhenghe-md.github.io/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/memory-disk.jpg">


<link rel="canonical" href="https://zhenghe-md.github.io/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://zhenghe-md.github.io/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/","path":"2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/","title":"用 LSM Tree 实现一个键值数据库 —— GopherConf 2017 演讲笔记"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>用 LSM Tree 实现一个键值数据库 —— GopherConf 2017 演讲笔记 | ZhengHe</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-172943223-1"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-172943223-1","only_pageview":false}</script>
  <script src="/blog/js/third-party/analytics/google-analytics.js"></script>





  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
<style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"] > svg a {
  fill: blue;
  stroke: blue;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container {
  overflow: auto hidden;
}

mjx-container + br {
  display: none;
}
</style><link rel="alternate" href="/blog/atom.xml" title="ZhengHe" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">ZhengHe</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-categories"><a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-about"><a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/ZhengHe-MD" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhenghe-md.github.io/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="ZhengHe">
      <meta itemprop="description" content="郑鹤的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhengHe">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          用 LSM Tree 实现一个键值数据库 —— GopherConf 2017 演讲笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-26 23:23:03" itemprop="dateCreated datePublished" datetime="2020-02-26T23:23:03+00:00">2020-02-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-10-10 14:53:27" itemprop="dateModified" datetime="2024-10-10T14:53:27+00:00">2024-10-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">系统设计</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="background">Background</h1>
<p>数据库中的各种奇技淫巧，实际上都来自于内存与磁盘的读写模式和性能区别。</p>
<p><img src="/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/memory-disk.jpg" width="500px"></p>

<p>总结如下表：</p>
<table>
<thead>
<tr class="header">
<th>Memory</th>
<th>Disk</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>byte-addressable</td>
<td>block-addressable</td>
</tr>
<tr class="even">
<td>fast</td>
<td>slow</td>
</tr>
<tr class="odd">
<td>expensive</td>
<td>cheap</td>
</tr>
</tbody>
</table>
<p>当数据库中的数据无法一次性装入内存时，数据的读写就可能需要从内存穿透到磁盘。在 OLTP 场景下，每次事务写入和读取的数据数量都不大。但因为磁盘是块存储设备，无论是否需要，写入和读取都以块 (block) 为单位：</p>
<p><img src="/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/file-block.jpg" width="500px"></p>
<p>这就导致许多不必要的数据传输。除此之外，在磁盘中连续读取或写入相邻的数据块比随机的数据块效率高。因此数据库在组织数据、索引时，为了减少不必要的 I/O，同时提高 I/O 的效率，就需要尽可能做到：</p>
<ul>
<li>让具有局部性的数据、索引在磁盘上相邻存储</li>
<li>让具有局部性的数据、索引批量写入到磁盘中</li>
</ul>
<p>从而达到两个目的：</p>
<ul>
<li>读出的数据都是需要的</li>
<li>写入的数据都是有用的</li>
</ul>
<h1 id="b-tree">B+ Tree</h1>
<p>B+ tree 作为数据库索引，已经被许多成熟的关系型数据库所验证。如下图所示：</p>
<p><img src="/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/b+tree.jpg" width="500px"></p>
<blockquote>
<p>ref: https://janzhou.org/2015/bf-tree-approximate-tree-indexing.html</p>
</blockquote>
<p>得益于其矮胖的平衡树形结构，且将所有数据置于叶子节点，B+ 树的读取性能好且稳定。但它的劣势在于，更新数据时成本较高，不仅要更新数据，还要更新索引。如果表中有多个索引，则都要更新，更新每个索引时还可能更新多个节点，因此写数据的性能在一些写要求苛刻的场景下并不能满足要求。</p>
<h1 id="lsm-tree">LSM Tree</h1>
<p>在键值数据库场景下，相较于 B+ 树，LSM 树能够提供更高效的写性能。LSM 树的基本思路就是批量写数据，即先将需要写入的数据放在内存中，等到达一定容量时再写入磁盘。其基本结构如下图所示：</p>
<p><img src="/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/lsm-tree.jpg" width="600px"></p>
<h2 id="buffer">Buffer</h2>
<p>在 buffer 中存储着最新写入的键值对数据，这些数据通常按照键的顺序存储在相应的有序数据结构中，如跳表。同时 Buffer 也是数据查询的入口，存储着最新鲜的数据，或者数据的最新版本。</p>
<h2 id="sorted-string-table-sst">Sorted String Table (SST)</h2>
<p>当 Buffer 中的数据容量到达一定阈值时，会被顺序地写入磁盘中。磁盘中的数据分为多个层次，每层的数据容量指数递增。每层数据又可以继续被划分为一个或多个 SST，每个 SST 中的数据按顺序排列。且同一层级中的多个 SST 之间的键数据通常不会有交集。每层数据量大小都有限制，当数据量达到阈值时，该层的某个 SST 需要与下一层的若干个 SST 合并 (merge)，流入下一层中。因此图中越上层的数据越新、越下层的数据量越大。</p>
<p>通常认为 SST 是不可变 (Immutable) 的数据结构，所有数据更新都通过写入新的 SST 实现，而所有合并操作也是通过生成新的 SST 实现。这种方式对实现数据库的多版本并发控制 (MVCC) 比较友好。</p>
<h2 id="writes">Writes</h2>
<p>写入键值数据时，先将数据插入放到内存中的缓存 (buffer) 数据结构中，写入请求就可以返回响应。这个过程完全在内存中，因此效率很高。这里的写入操作包含插入、更新和删除，对于 LSM Tree 来说，更新和删除也是插入新的键值对，只不过删除存放的值是一个删除标记。</p>
<p>需要注意的是，大部分数据库为了保证 durability，都会将操作日志写入 WAL (write-ahead log) 中，因此这里实际上每次写数据，都有日志落盘。但因为日志是 append-only 的结构，因此这种写入的效率通常很高。</p>
<h2 id="merge-compaction">Merge (Compaction)</h2>
<p>上文提到，disk 中每层数据都有容量限制，当 L 层数据超过阈值时，需要将 L 层的某个 SST 与 L+1 层中键的范围与该 SST 有重叠的多个 SST 合并，产生新的一组 SST 存放在 L+1 层中。如果此时 L+1 层中的数据容量也达到阈值，则会触发连续的合并。</p>
<p>在合并的过程中，相同键的值会被合并，只留下最新的值或者被删除，因此合并的过程也是压缩 (compaction) 的过程。</p>
<h2 id="lookups">Lookups</h2>
<p>由于上层的数据比下层的新，因此单条数据的查询首先从 buffer 开始，然后到 L0，L1，...，Ln，在每层数据查询时可以使用二分查找。范围查询也类似，可能需要查询多层数据。这种结构对于具有时间局部性的数据效率更高。</p>
<p>有许多优化手段可以避免每次查询都在每层的每个 SST 上执行二分查找。最常见的有两种，fence pointers 和 Bloom filters。</p>
<h3 id="fence-pointers">fence pointers</h3>
<p>fence pointers 的思路就是记录每个 SST 中建的最大值和最小值，由于每层中的多个 SST 的键值范围互相不重叠，这样对于单个键的查询，就能将查找范围缩小到某一个 SST 中。</p>
<h3 id="bloom-filters">Bloom filters</h3>
<p>bloom filter 则是在 fence pointers 之前的一层过滤器，通过其较低的 FP(false positive)，将大多数不必要的查询拒之门外。</p>
<p>整个数据查询的架构如下图所示：</p>
<p><img src="/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/lsm-tree-with-bloom-filters.jpg" width="500px"></p>
<h2 id="tiering-leveling">Tiering &amp; Leveling</h2>
<p>在 LSM 树的实现中，合并时间点的选择决定了该实现的读写性能取舍。通常合并地越频繁，读取数据所涉及的 SST 数量越少，读性能越好，与此同时写操作的放大效应越大，单条数据被合并的次数越多，写性能越差。</p>
<p><img src="/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/tiering-leveling.jpg" width="500px"></p>
<p>在 Tiering 中，每一层数据有多个 SST；在 Leveling 中，每一层数据通常只有一个 SST：</p>
<p><img src="/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/tiering-leveling-2.jpg" width="500px"></p>
<p>其中两层之间的容量比例是很重要的参数，记为 R。R 越大，则层数越少；R 越小，则层数越多。数据的总层数为 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex" xmlns="http://www.w3.org/2000/svg" width="6.187ex" height="2.034ex" role="img" focusable="false" viewBox="0 -694 2734.7 899" xmlns:xlink="http://www.w3.org/1999/xlink"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><use xlink:href="#MJX-TEX-I-6C"></use></g><g data-mml-node="mi" transform="translate(298, 0)"><use xlink:href="#MJX-TEX-I-6F"></use></g><g data-mml-node="msub" transform="translate(783, 0)"><g data-mml-node="mi"><use xlink:href="#MJX-TEX-I-67"></use></g><g data-mml-node="TeXAtom" transform="translate(477, -150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use xlink:href="#MJX-TEX-I-52"></use></g></g></g><g data-mml-node="mi" transform="translate(1846.7, 0)"><use xlink:href="#MJX-TEX-I-4E"></use></g></g></g></svg></mjx-container></span> 。当 R 很小时，Tiering 与 Leveling 的效果趋于一致。通常 Tiering 中的 R 比较大，而 Leveling 的 R 比较小，如下图所示：</p>
<p><img src="/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/tiering-leveling-curve.jpg" width="400px"></p>
<p>考虑极端情况：当 R 很小时，相邻两层数据容量差别小，每层数据就是一个 sorted array，在每层中查找数据只需一次二分查找，这种情况下读性能好；当 R 很大时，每层数据约等于没有顺序，就像日志一样，这种情况下写性能好。</p>
<p>很自然的，不同业务场景对读写性能有不同的需求，因此在各个 R 上都有相应的键值数据库存在：</p>
<p><img src="/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/tiering-leveling-curve-with-products.jpg" width="400px"></p>
<h1 id="case-study-couchbasemoss">Case Study: couchbase/moss</h1>
<p>moss 是由 couchbase 的工程师开发的键值数据库，本节的 case study 来自于 Marty Schoch 在 GopherConf 2017 上的分享：<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=ttebJcN5bgQ">Building a High-Performance Key/Value Store in Go</a>。</p>
<h2 id="general-purpose-key-value-stores">General Purpose Key-Value Stores</h2>
<p>站在 Go 语言工程师的角度上，通用键值数据库中的 key 和 value 就是 byte slice：</p>
<p><img src="/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/moss-kv.jpg" width="400px"></p>
<p>通用键值数据库通常需要支持：</p>
<ol type="1">
<li>Get/Set/Delete Values by Key</li>
<li>Iterate Ranges of Key-Value Pairs</li>
<li>Atomic Batch Updates</li>
<li>Isolated Read Snapshots</li>
<li>Persistence to Disk</li>
</ol>
<p>1， 2， 3， 5 项都容易理解，Isolated Read Snapshots 其实就是 MVCC，即当用户开始遍历键值数据时，之后的数据更新对当前的遍历不可见。</p>
<h2 id="special-purpose-key-value-store">Special Purpose Key-Value Store</h2>
<p>moss 团队需要的并非一个通用键值数据库，他们有特殊的性能关注点：</p>
<p><img src="/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/moss-requirements.jpg" width="500px"></p>
<ol type="1">
<li>写吞吐</li>
<li>写入数据后到能查询之间的时延</li>
</ol>
<h2 id="off-the-shelf-solutions">Off-The-Shelf Solutions</h2>
<p>在决定开发自己的键值数据库之前，moss 工程师也调研了一些市面上开源的数据库，如 BoltDB, RocksDB, GoLevelDB 以及 Badger。</p>
<h3 id="boltdb">BoltDB</h3>
<p>BoltDB 是 Go 语言编写的键值数据库。BoltDB 通过单线程解决并发控制解决方案，支持可序列化事务隔离，通过成熟的 B+ 树来解决内存、磁盘读写模式的不匹配问题，BoltDB 已经在许多商业系统中成功运用，其可靠性也得到了验证。它的优势在于极高的读效率，但由于它使用 B+ 树，天然地其写性能要弱于使用 LSM 树的键值数据库解决方案。</p>
<p>有关 BoltDB 的分析可参考本人的项目 <a target="_blank" rel="noopener" href="https://github.com/ZhengHe-MD/learn-bolt">ZhengHe-MD/learn-bolt</a>。</p>
<h3 id="rocksdb">RocksDB</h3>
<p>RocksDB 是基于 google 的 LevelDB 二次开发的键值数据库，其内部采用了 LSM 树设计，在 Write-Amplification-Factor (WAF)、Read-Amplification-Factor (RAF) 和 Space-Amplification-Factor (SAF) 中取得更灵活的权衡，它支持多线程数据压缩，能够处理 TB 级别数据。相较于 BoltDB，RocksDB 有更好的读写性能平衡，但它使用 C++ 编写，使得 moss 工程师需要利用 cgo 来跨越 Go 和 C++ 的边界，且这一层边界开销也有一定的性能损耗，因此 moss 团队没有采用 RocksDB。</p>
<h3 id="goleveldb">GoLevelDB</h3>
<p>GoLevelDB 是 LevelDB 的 Go 语言原生实现，其同样采用 LSM 树设计，但经过反复调试，moss 团队发现它无法达到其读写性能的高要求，因此放弃。</p>
<h3 id="badger">Badger</h3>
<p>在 moss 团队开始寻找键值数据库解决方案时，badger 项目还未开源，因此无法验证其是否满足需求。</p>
<h2 id="design-philosophy">Design Philosophy</h2>
<p>Rob Pike 在 Notes on C Programming 说道：</p>
<blockquote>
<p>Rule3: Fancy algorithms are slow when n is small, and n is usually small. Fancy algorithms have big constants. Until you know that n is frequently going to be big, don't get fancy.</p>
<p>Rule4: Fancy algorithms are buggier than simple ones, and they're much harder to implement. Use simple algorithms as well as simple data structures.</p>
</blockquote>
<p>Dave Cheney 提到：</p>
<blockquote>
<p>Simplicity cannot be added later</p>
</blockquote>
<p>moss 团队的设计理念非常明确：能简则简。</p>
<h2 id="interface-design">Interface Design</h2>
<h3 id="collection">Collection</h3>
<p>在 moss 中，每个数据库就是一个 Collection，它只暴露两个接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Collection <span class="keyword">interface</span> {</span><br><span class="line">    ExecuteBatch(b Batch) error</span><br><span class="line">    Snapshot() (Snapshot, error)</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>它的设计十分精简：</p>
<ul>
<li>所有写数据操作都是一个 Batch</li>
<li>所有读数据操作都从一个 Snapshot 上发起</li>
</ul>
<h3 id="batch">Batch</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Batch <span class="keyword">interface</span> {</span><br><span class="line">    Set(key, value []<span class="keyword">byte</span>) error</span><br><span class="line">    Delete(key []<span class="keyword">byte</span>) error</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="snapshot">Snapshot</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Snapshot <span class="keyword">interface</span> {</span><br><span class="line">    Get(key []<span class="keyword">byte</span>) ([]<span class="keyword">byte</span>, error)</span><br><span class="line">    Iterator(start, end []<span class="keyword">byte</span>) (Iterator, error)</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="basic-idea">Basic Idea</h2>
<p>moss 的解决方案很简单，用户写入一批键值数据 (这里忽略其值)，如下图所示：</p>
<p><img src="/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/moss-basic-idea-1.jpg" width="500px"></p>
<p>如果可以将这批数据按 key 排序：</p>
<p><img src="/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/moss-basic-idea-2.jpg" width="500px"></p>
<p>就可以很方便地查询数据：</p>
<ul>
<li>查询单个键：二分查找</li>
<li>范围查询：二分查找 + 循环遍历</li>
</ul>
<p><img src="/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/moss-basic-idea-3.jpg" width="500px"></p>
<h2 id="data-layout">Data Layout</h2>
<p>将用户插入的一批数据成为 Batch，在数据库内部排序后称为 Segment：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> segment <span class="keyword">struct</span> {</span><br><span class="line">    data []<span class="keyword">byte</span></span><br><span class="line">    meta []<span class="keyword">uint64</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>假设用户执行：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set([]<span class="keyword">byte</span>(<span class="string">"name"</span>), []<span class="keyword">byte</span>(<span class="string">"marty"</span>))</span><br></pre></td></tr></table></figure>
<p>接收该键值对的 segment 会将 "name" 和 "marty" 依次 append 到 data 之后，并在 meta 中增加 2 个 uint64 的元数据：</p>
<p><img src="/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/moss-data-layout-1.jpg" height="200px"></p>
<ul>
<li>20 表示键值数据在 data 中的偏移量</li>
<li>s 表示操作名称 (set)</li>
<li>4、5 分别表示键和值的长度</li>
</ul>
<p>元数据中的两个 uint64 具体结构如下：</p>
<p><img src="/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/moss-data-layout-2.jpg" height="150px"></p>
<p>这样存储的好处是，排序时只需要调整 meta，而无需修改 data。</p>
<p>显然用户会向数据库中插入许多 batch，每当插入新的 batch 时，moss 数据库就先将 batch 原地排序，然后插入到 segmentStack 中，并用锁来保护 segmentStack 的并发安全：</p>
<p><img src="/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/moss-data-layout-3.jpg" width="400px"></p>
<p><img src="/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/moss-data-layout-4.jpg" width="400px"></p>
<p>在 segmentStack 中，新的 segment 在栈顶，老的 segment 在栈底。这种结构与 LSM 树如出一辙，新的数据在栈顶，老的数据在栈底。</p>
<h2 id="operation">Operation</h2>
<h3 id="get">Get</h3>
<p>当用户要查询单个键时，就从栈顶的 segment 开始，依次对每个 segment 执行二分查找，直到找到键值数据或遍历完整个 segmentStack。</p>
<h3 id="iteration">Iteration</h3>
<p>利用小根堆，将每个 segment 中排序最小的元素开始放入小根堆中：</p>
<p><img src="/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/moss-iteration.jpg" width="500px"></p>
<p>读取堆顶元素，然后从相应的 segment 中补进新元素，直到遍历完成所有 segments，也就完成了 iteration 的操作。</p>
<h3 id="atomic-batches">Atomic Batches</h3>
<p>利用锁来保护 segmentStack 的并发安全即可。</p>
<h3 id="isolated-snapshots">Isolated Snapshots</h3>
<p>在 moss 眼中，所有 segments 都是 immutable 的数据，一旦 batch 变成 segment，该 segment 中的数据就不会再发生变化。这时候支持 Isolated Snapshots/MVCC 就很容易了，因为 segmentStack 保存的是对 segment 的指针，只要复制一份 segmentStack 即可满足要求。新到来的写入操作不会改变已存在的 segment。</p>
<h3 id="background-merger">Background Merger</h3>
<p>当然，如果一直往 segmentStack 中压入 segment，前者会变得很长，数据读取的效率会下降，这时候就需要合并：</p>
<p><img src="/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/moss-background-merger-1.jpg" width="400px"></p>
<p><img src="/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/moss-background-merger-2.jpg" width="400px"></p>
<h2 id="database-file">Database File</h2>
<p>moss 的数据库文件形式为 append-only，内部数据存储的内容如下所示：</p>
<p><img src="/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/moss-database-file-1.jpg" width="400px"></p>
<p>其中 footer 中保存着指向 segments 偏移量的指针，且每个 footer 都保存对之前所有 segments 的指针。数据库启动时，会打开该文件，从后往前找到第一个合法的 Footer。如果最后一个 Footer 没有完整写入，数据库会找到更早的 Footer，当然这会丢失一些数据，但不影响数据库的正常运行。另外考虑到 WAL，数据的持久性依然可以得到保障。</p>
<p>从数据库读取文件后，moss 会将相应的 segments mmap 到内存中，让操作系统来处理内存管理逻辑：</p>
<p><img src="/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/moss-database-file-2.jpg" width="400px"></p>
<p>此外，moss 还会利用 background merger 将文件中的 segments 合并。类似地，所有 segments 都是 immutable 的数据，每次合并都将生成新的数据文件：</p>
<p><img src="/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/moss-database-file-3.jpg" width="400px"></p>
<p>从而保障 Isolated Read Snapshots 正常进行。</p>
<h1 id="references">References</h1>
<ul>
<li>Projects
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/couchbase/moss">github: couchbase/moss</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/google/leveldb">github: google/leveldb</a>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/master/doc/impl.md">doc/impl.md</a></li>
</ul></li>
<li><a target="_blank" rel="noopener" href="https://github.com/facebook/rocksdb">github: facebook/rocksdb</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/syndtr/goleveldb">github: syndtr/goleveldb</a></li>
</ul></li>
<li>Books
<ul>
<li><a target="_blank" rel="noopener" href="https://www.amazon.com/Getting-Started-LevelDB-Andy-Dent/dp/1783281014">Getting Started with LevelDB</a></li>
</ul></li>
<li>Blogs
<ul>
<li><a target="_blank" rel="noopener" href="https://www.igvita.com/2012/02/06/sstable-and-log-structured-storage-leveldb/">SSTable and Log Structured Storage: LevelDB</a></li>
</ul></li>
<li>Courses
<ul>
<li><a target="_blank" rel="noopener" href="http://daslab.seas.harvard.edu/classes/cs265/project.html">CS265: Big Data Systems: An LSM-Tree Based Key-Value Store</a></li>
</ul></li>
<li>Videos
<ul>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=b6SI8VbcT4w">Youtube: Scaling Write-Intensive Key-Value Store by Microsoft Research</a></li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=ttebJcN5bgQ">Youtube: Building a High-Performance Key-Value Store in Go by Marty Schoch</a> &amp; <a target="_blank" rel="noopener" href="https://speakerdeck.com/mschoch/value-store-in-go?slide=3">slides</a></li>
</ul></li>
</ul>
<svg style="display: none" id="MJX-SVG-global-cache"><defs><path id="MJX-TEX-I-6C" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path><path id="MJX-TEX-I-6F" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path><path id="MJX-TEX-I-67" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"></path><path id="MJX-TEX-I-52" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path><path id="MJX-TEX-I-4E" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></defs></svg>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="followme">
  <span>欢迎关注我的其它发布渠道</span>

  <div class="social-list">

      <div class="social-item">
        <a target="_blank" class="social-link" href="/blog/atom.xml">
          <span class="icon">
            <i class="fa fa-rss"></i>
          </span>

          <span class="label">RSS</span>
        </a>
      </div>
  </div>
</div>


        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/blog/2020/02/19/Cache-Policies/" rel="prev" title="缓存管理策略综述">
                  <i class="fa fa-chevron-left"></i> 缓存管理策略综述
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/blog/2020/02/27/The-Evolution-of-Prometheus-Storage-Layer/" rel="next" title="Prometheus TSDB 的存储层演进 —— PromConf 演讲笔记">
                  Prometheus TSDB 的存储层演进 —— PromConf 演讲笔记 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZhengHe</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/blog/js/comments.js"></script><script src="/blog/js/utils.js"></script><script src="/blog/js/schemes/muse.js"></script><script src="/blog/js/next-boot.js"></script>

  





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/blog/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"zhenghe-hexo-blog","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/blog/js/third-party/comments/disqus.js"></script>

</body>
</html>
