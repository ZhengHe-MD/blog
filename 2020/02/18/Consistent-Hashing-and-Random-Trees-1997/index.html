<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zhenghe-md.github.io","root":"/blog/","images":"/blog/images","scheme":"Mist","darkmode":false,"version":"8.27.0","exturl":false,"sidebar":{"position":"left","display":"remove","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"tomorrow-night"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null}},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/blog/js/config.js" defer></script>



<link rel="canonical" href="https://zhenghe-md.github.io/blog/2020/02/18/Consistent-Hashing-and-Random-Trees-1997/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://zhenghe-md.github.io/blog/2020/02/18/Consistent-Hashing-and-Random-Trees-1997/","path":"2020/02/18/Consistent-Hashing-and-Random-Trees-1997/","title":"Consistent Hashing and Random Trees (1997)"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Consistent Hashing and Random Trees (1997) | ZhengHe</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-172943223-1"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-172943223-1","only_pageview":false}</script>
  <script src="/blog/js/third-party/analytics/google-analytics.js" defer></script>








  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/blog/js/utils.js" defer></script><script src="/blog/js/next-boot.js" defer></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/blog/js/third-party/math/mathjax.js" defer></script>



  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
<link rel="alternate" href="/blog/atom.xml" title="ZhengHe" type="application/atom+xml">
<style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">ZhengHe</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-about"><a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
  </ul>
</nav>




</header>
    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhenghe-md.github.io/blog/2020/02/18/Consistent-Hashing-and-Random-Trees-1997/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="ZhengHe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhengHe">
      <meta itemprop="description" content="郑鹤的博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Consistent Hashing and Random Trees (1997) | ZhengHe">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Consistent Hashing and Random Trees (1997)
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-18 17:33:21" itemprop="dateCreated datePublished" datetime="2020-02-18T17:33:21+00:00">2020-02-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2026-02-02 14:44:23" itemprop="dateModified" datetime="2026-02-02T14:44:23+00:00">2026-02-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AE%BA%E6%96%87/" itemprop="url" rel="index"><span itemprop="name">论文</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2020/02/18/Consistent-Hashing-and-Random-Trees-1997/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/02/18/Consistent-Hashing-and-Random-Trees-1997/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>论文作者的贡献主要包含两部分：Consistent Hashing 和 Random
Trees。Consistent Hashing 主要用于解决分布式哈希表 (Distributed Hash
Table, DHT) 的桶增减带来的重新哈希问题；Random Trees
主要用于分布式缓存中的热点问题，它利用了 Consistent
Hashing。下文主要关注 Consistent Hashing。</p>
<span id="more"></span>
<h1 id="contribution">Contribution</h1>
<p>在分布式环境下，单台机器的负载有限，我们需要将请求散列到不同的机器上，利用更多的机器实现服务的横向扩容。这时候就需要
Hash Function，好的 Hash Function
能够帮我们均匀地分布到不同的机器上。但传统的 Hash Function
通常是静态的，桶的数量固定。在多台机器组成的服务中，每台机器就是一个桶，但机器在运行的过程中很可能出现崩溃，在请求数量波动较大时，需要动态地增减机器。如果每次桶的数量发生变化时都需要重新散列所有请求，可能造成多方面影响：</p>
<ul>
<li>来自于同一个用户的请求在桶发生变化时将被打到不同的节点，可能导致数据不一致
(考虑 monotonic consistency)</li>
<li>所有的 Client 都需要知道当前最新的 Hash Function
配置，在网络中传播这个配置需要时间</li>
</ul>
<p>Consistent Hashing
的提出就是希望能够缓解/解决这个问题，使得每次桶数量发生变化时不需要重新散列桶内的所有元素，而是将受影响的数量控制在很小的范围内。</p>
<h1 id="definitions">Definitions</h1>
<p>作者从四个方面讨论了好的 Consistent Hash Function
应该满足的性质：</p>
<ul>
<li>Balance：元素应当尽量均匀地分布到不同的桶内 (with high
probability)</li>
<li>Monotonicity：当增加新的桶时，元素只可能从旧桶移动到新桶，而不可能从旧桶移动到其它旧桶</li>
<li>Spread：在不同的用户眼里，相同的元素可能被散列到不同的桶中，我们称之为不同的观点。Spread
要求总的观点数量必须有一个上限。好的 Consistent Hash Function 应当让
spread 尽量小。</li>
<li>Load：类似 spread，Load
性质是针对不同的用户，但它规定的是单个桶中不同元素数量的上限，即每个桶中的，至少有一个用户认为其中含有的，元素数量存在上限。好的
Consitent Hash Function 应当让这个上限尽量小。</li>
</ul>
<h1 id="construction">Construction</h1>
<p>作者提出一种构建好的 Consistent Hash Function 的方法：</p>
<p>假设我们有两个随机的函数 <span class="math inline"><em>r</em><sub><em>B</em></sub></span> 和 <span class="math inline"><em>r</em><sub><em>I</em></sub></span> ：</p>
<ul>
<li><span class="math inline"><em>r</em><sub><em>B</em></sub></span>将
buckets 映射到区间 <span class="math inline">[0,1]</span> 上</li>
<li><span class="math inline"><em>r</em><sub><em>I</em></sub></span>将
items 映射到区间 <span class="math inline">[0,1]</span> 上</li>
</ul>
<p>那么一个好的 Consistent Hash Function 可以定义为 <span class="math inline"><em>f</em><sub><em>V</em></sub>(<em>i</em>) = <em>m</em><em>i</em><em>n</em>(|<em>r</em><sub><em>B</em></sub>(<em>b</em>)−<em>r</em><sub><em>I</em></sub>(<em>i</em>)|)</span>
，即将 item 放在距离它最近的 bucket 中。这里的 V
代表着不同的观点，由于观点数量会随着 buckets
的增减而增加，每个观点的内容会随着 buckets 的增减而变化，因此这个
Consistent Hash Function 并不是一个静态的、固定的函数。</p>
<p>这里还有一点，<span class="math inline"><em>r</em><sub><em>B</em></sub></span>
通常需要将每个 bucket 映射到 <span class="math inline">[0,1]</span>区间的多个点上。假设整个区间上的 bucket
数量上限为 <span class="math inline"><em>C</em></span> ，那么 <span class="math inline"><em>r</em><sub><em>B</em></sub></span> 需要将每个
bucket 映射到 <span class="math inline"><em>k</em>log <em>C</em></span>
个点上，其中 <span class="math inline"><em>k</em></span> 为常数，且
<span class="math inline"><em>r</em><sub><em>B</em></sub></span>
在映射单个 bucket 的不同点时，是相互独立的。</p>
<p>接着论文证明了上述函数满足 Monotonicity、Balance、Spread 和 Load
四个特性，这里简要说明一下证明的直觉：</p>
<ul>
<li>Monotonicity：新增 bucket 时，新的 bucket 会被映射到 <span class="math inline"><em>k</em>log <em>C</em></span>
个随机的点上，而这些点周围的 items 可能会被新的 bucket 抢过来，因为新的
bucket 离它们更近，但绝不会出现 items 被旧的 bucket 抢走的情况，因此
Monotonicity 被满足。</li>
<li>Balance：因为每个 bucket 的 <span class="math inline"><em>k</em>log <em>C</em></span> 个点会随机分布在
<span class="math inline">[0,1]</span> 上，因此每个 bucket 将管辖不超过
<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.816ex;" xmlns="http://www.w3.org/2000/svg" width="4.261ex" height="3.185ex" role="img" focusable="false" viewBox="0 -1047.1 1883.2 1407.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mfrac"><g data-mml-node="mrow" transform="translate(220,516.8) scale(0.707)"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(1152,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1652,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g><g data-mml-node="mi" transform="translate(669.7,-345) scale(0.707)"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"></path></g><rect width="1643.2" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container></span> 长度的区间 (with high
probability)。由于 items 会被随机地、均匀地分布在整个区间上，因此
Balance 被满足。</li>
<li>Spread：假设某个 item 被 <span class="math inline"><em>r</em><sub><em>l</em></sub></span>映射到 <span class="math inline">[0,1]</span>上的某个点，那么每个观点 <span class="math inline"><em>V</em></span> 中，最接近 item 的 bucket
只有一个。由于 buckets 会被 <span class="math inline"><em>r</em><sub><em>B</em></sub></span>随机、均匀地映射到整个区间，因此即使随着
buckets 数量的增减，观点的数量会增加，但可以想象，不可能所有新 bucket
对应的映射点都在 item 周围，位于它周围的 bucket
映射点数量应当有个上限。因此 Spread 被满足。</li>
<li>Load：类似 spread 的推理，把 item 和 bucket 位置对调即可。即对于每个
bucket 来说，映射到它附近的 items 数量应当有个上限。因此 Load
被满足。</li>
</ul>
<h1 id="implementation">Implementation</h1>
<p>Consistent Hashing 在许多场景下都有应用，比如：</p>
<ul>
<li>负载均衡</li>
<li>P2P 系统</li>
<li>数据库分片</li>
<li>…</li>
</ul>
<p>尽管场景很多，但它们对 DHT 的要求不一样：</p>
<h2 id="负载均衡">负载均衡</h2>
<p>在云原生环境下，为了保证服务的扩展性和可用性，通常会同时启动一个服务的多个实例。如何把不同的请求合理地反向代理到不同实例，是负载均衡器需要解决的问题。</p>
<p><img src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LMjQD5UezC9P8miypMG%2F-Ls0CbucFiDOfzdxatcA%2F-Ls0HCUULJNLchbiL-F6%2FLoad-Balancer.jpg?alt=media&amp;token=71a7a887-90dd-42c7-bbe2-8c83e410a2d6" style="zoom:67%;"></p>
<p>为了保证服务的数据单调一致性，一些服务要求同一个用户的请求必须被路由到同一个实例。这时候就需要对用户的身份标识数据做一次哈希操作，找到固定的实例。但在云原生环境下，同一个服务的实例数量以及地址可能常常发生变化，为使得因实例变动影响到的用户数量最小，就需要使用
Consistent Hashing。</p>
<p>和其它场景不同，Consistent Hashing
在负载均衡场景下，实例数量发生变化时，实际上没有主动重新哈希已有数据的过程，因为它不需要保持对应关系数据。</p>
<h3 id="实现思路">实现思路</h3>
<p>材料：哈希函数： <span class="math inline"><em>H</em>(<em>x</em>)：<em>s</em><em>t</em><em>r</em><em>i</em><em>n</em><em>g</em> → [0,<em>m</em><em>a</em><em>x</em>]</span></p>
<p>方案：将每个节点哈希到区间 <span class="math inline">[0,<em>m</em><em>a</em><em>x</em>]</span> 上随机的
<span class="math inline"><em>k</em></span>
个点，将所有节点的所有哈希值排序后保存在一个数组 <span class="math inline"><em>A</em></span> 中。每次新来一个请求，就将请求的
ID 哈希到区间 <span class="math inline">[0,<em>m</em><em>a</em><em>x</em>]</span>
上的某个点，然后利用二分查找找到比 k
大的最小点，后者对应的节点就是目标实例。</p>
<p>算法复杂度分析：</p>
<table>
<thead>
<tr class="header">
<th>操作</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>AddNode</td>
<td><span class="math inline"><em>O</em>(<em>k</em><em>l</em><em>o</em><em>g</em>(<em>n</em>))</span></td>
</tr>
<tr class="even">
<td>DelNode</td>
<td><span class="math inline"><em>O</em>(<em>k</em><em>l</em><em>o</em><em>g</em>(<em>n</em>))</span></td>
</tr>
<tr class="odd">
<td>Get</td>
<td><span class="math inline"><em>O</em>(<em>l</em><em>o</em><em>g</em><em>k</em><em>n</em>)</span></td>
</tr>
</tbody>
</table>
<h3 id="实现示例">实现示例</h3>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/stathat/consistent">stathat/consistent</a>。</li>
</ul>
<h2 id="p2p-系统">P2P 系统</h2>
<h3 id="pastry">Pastry</h3>
<ul>
<li>video
<ul>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=WqQRQz_XYg4&amp;t=303s">Routing in
Distributed Hash Tables | Anne-Marie Kermarrec</a></li>
</ul></li>
<li>paper
<ul>
<li><a target="_blank" rel="noopener" href="http://rowstron.azurewebsites.net/PAST/pastry.pdf">Pastry:
Scalable, decentralized object location and routing for large-scale
peer-to-peer systems</a></li>
</ul></li>
</ul>
<h2 id="数据库分片">数据库分片</h2>
<p>(TODO)</p>
<h1 id="参考">参考</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.akamai.com/us/en/multimedia/documents/technical-publication/consistent-hashing-and-random-trees-distributed-caching-protocols-for-relieving-hot-spots-on-the-world-wide-web-technical-publication.pdf">Consistent
Hashing and Random Trees</a></li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="followme">
  <span>欢迎关注我的其它发布渠道</span>

  <div class="social-list">

      <div class="social-item">
          <a target="_blank" class="social-link" href="/blog/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
      </div>
  </div>
</div>


        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/blog/2020/02/18/Dynamic-Hash-Tables-1988/" rel="prev" title="Dynamic Hash Tables (1988)">
                  <i class="fa fa-angle-left"></i> Dynamic Hash Tables (1988)
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/blog/2020/02/19/Cache-Policies/" rel="next" title="缓存管理策略综述">
                  缓存管理策略综述 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2026</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">ZhengHe</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/ZhengHe-MD" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"zhenghe-hexo-blog","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/blog/js/third-party/comments/disqus.js" defer></script>

</body>
</html>
