<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZhengHe</title>
  <icon>https://zhenghe-md.github.io/blog/icon.png</icon>
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://zhenghe-md.github.io/blog/"/>
  <updated>2021-10-06T14:41:42.290Z</updated>
  <id>https://zhenghe-md.github.io/blog/</id>
  
  <author>
    <name>ZhengHe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「笨学指南」</title>
    <link href="https://zhenghe-md.github.io/blog/2021/10/06/Announcing-the-start-of-project-LTTHW/"/>
    <id>https://zhenghe-md.github.io/blog/2021/10/06/Announcing-the-start-of-project-LTTHW/</id>
    <published>2021-10-06T19:55:53.000Z</published>
    <updated>2021-10-06T14:41:42.290Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;国庆前夕，我利用业余时间过了一遍 YC 的 &lt;a href=&quot;https://www.youtube.com/playlist?list=PLQ-uHSnFig5OMuEYI4rnNz08BIHxhxdHG&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Startup School 2019&lt;/a&gt; 的系列课程，甚至煞有介事地写了一份 YC application，这样便算是完成了所有准备工作。而国庆期间，我哪也没去，希望能集中精力完成「笨学指南」的原型，并在国庆后利用闲暇时间执行下一步计划。&lt;/p&gt;
&lt;p&gt;今天，我终于可以很开心地宣布：&lt;strong&gt;笨学指南的&lt;a href=&quot;https://learn-things-the-hard-way.vercel.app/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原型&lt;/a&gt;已经完成&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;为什么&quot;&gt;为什么&lt;/h2&gt;
&lt;p&gt;我有一个观察：「学习本身是一种基本技能，对这项技能的掌握程度决定了每个人在各自专业知识领域可达的上限」。&lt;/p&gt;
&lt;p&gt;我是一名软件工程师，就以软件开发为例展开。一位优秀的工程师，首先得是一名资深的搜索引擎用户，他需要具备寻找优质资料的能力，公开课、技术会议、经典教材、论文、开源项目、标准协议、原始技术文档等，都应该位于他的「射程范围」内；鉴于这些资料大多数由英语撰写，英语能力被迫成为优秀工程师的必备能力之一；最后就是资料的学习、理解并内化的能力。这项能力并没有什么神奇的地方，说白了就是「重复」，让大脑暴露在这些知识中，建立知识之间的联系，并不断地强化。总而言之，刨除个人软素质部分，成为一位优秀的软件工程师的必要条件是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;善于寻找资料&lt;/li&gt;
&lt;li&gt;熟练使用英语&lt;/li&gt;
&lt;li&gt;持续学习强化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里的「熟练使用英语」是因为软件开发领域的特殊性所引入，在别的领域它不是必要条件，比如打羽毛球。&lt;/p&gt;
&lt;p&gt;我相信很多人都认识到了掌握学习能力本身的重要性；但我也相信，&lt;strong&gt;许多人需要改善自己的学习能力&lt;/strong&gt;，这便是我想要解决的问题。&lt;/p&gt;
&lt;h3 id=&quot;为什么要解决这个问题&quot;&gt;为什么要解决这个问题？&lt;/h3&gt;
&lt;p&gt;学习新知总能让我持续感到兴奋，它是我自认为喜欢、擅长又乐在其中的事情。“知之者不如好之者，好之者不如乐之者”。举个例子：我夫人是个很喜欢出门游玩的人，而我喜欢周末宅在家里看书、听课。有一天，她想了个办法，建议我学习摄影，正好她喜欢拍好看的照片，我觉得很有道理，欣然接收并立即开始听摄影课。现在只要有模特，叫我去哪里我都乐意。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>对话系统调研报告</title>
    <link href="https://zhenghe-md.github.io/blog/2021/07/24/dialogue-system-research/"/>
    <id>https://zhenghe-md.github.io/blog/2021/07/24/dialogue-system-research/</id>
    <published>2021-07-24T09:37:30.000Z</published>
    <updated>2021-10-06T14:41:42.346Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;今年 6 月底，由于工作需要，花了两周时间调研对话系统，并在公司内部做了一次调研报告。本文意在将此报告整理成文字版，算是对这段时间付出的一个交代。如果你对这个领域没有过了解，正好你也对此感兴趣，希望本文能够帮助你从以下几个方面提升你对「对话系统」的理解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;问题背景&lt;/li&gt;
&lt;li&gt;使用场景&lt;/li&gt;
&lt;li&gt;基本概念&lt;/li&gt;
&lt;li&gt;构建方式&lt;/li&gt;
&lt;li&gt;基本架构&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后将以 &lt;a href=&quot;https://github.com/RasaHQ/rasa&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Rasa&lt;/a&gt; 为例，介绍一个真实的对话系统项目。&lt;/p&gt;
&lt;h2 id=&quot;背景知识&quot;&gt;背景知识&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;ℹ️ 本节内容主要来自于 Speech and Language Processing 这本书的&lt;a href=&quot;https://web.stanford.edu/~jurafsky/slp3/24.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;第 24 章&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对话系统，顾名思义是用来与真人对话的系统。要做好这样的系统，了解、学习和研究「人类对话的特点」很有必要。&lt;/p&gt;
&lt;h3 id=&quot;人类对话的特点&quot;&gt;人类对话的特点&lt;/h3&gt;
&lt;p&gt;人类对话的特点理论上属于自然语言学的研究范畴，内容丰富，这里仅摘取其中一些要点。但如果有一天你想要把对话系统做到极致，系统地学习更多自然语言研究成果肯定能自底向上地帮助到你。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;轮次 (turns)：典型的对话通常由以对话双方轮流发言的形式出现，一来一回合称一轮 (turn)，来回多次被称为多轮对话。&lt;/li&gt;
&lt;li&gt;对话行为 (dialogue acts)：人们的每次发言或多或少都会带着一些目的，即可以是粗粒度的，如表述 (constatives)、请求 (requests)、指令 (directives)、承诺 (commissives)、表态 (acknowledgements)、问题 (questions)，也可以是细粒度的，如询问天气、预约时间、预定机票等等。&lt;/li&gt;
&lt;li&gt;共识确认 (grounding)：在对话过程中，为了保证双方的认识一致，沟通过程中会通过各种方式确认对方的想法。确认方式大致可以分为显式和隐式两种，举例如下：
&lt;ul&gt;
&lt;li&gt;显式：
&lt;ul&gt;
&lt;li&gt;A：我肚子在叫……&lt;/li&gt;
&lt;li&gt;B：你是不是想吃午饭了？&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;隐式：
&lt;ul&gt;
&lt;li&gt;A：我今天想快点去上海……&lt;/li&gt;
&lt;li&gt;B：好的，那你想从首都机场还是大兴机场出发？(隐含确认出行方式)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;对话结构 (dialogue structure)：通过分析不同的对话，我们会发现对话常常由基本问答加上一些特殊变化构成。特殊变化包括题外话 (side sequence)、前置语句 (presequences)、后置语句 (postsequences)、重复确认 (clarification) 等等。&lt;/li&gt;
&lt;li&gt;主导性 (initiative)：当对话中有一方一直在单向获取另一方信息时，我们称前者为主动方，后者为被动方。在对话系统中，对话双方是用户 (user) 和系统 (system)，那么从主导性出发，对话系统可以被分为三类：用户主导 (user-initiative)、系统主导 (system-initiative) 和混合主导 (mixed initiative)。&lt;/li&gt;
&lt;li&gt;推理和隐喻 (inference &amp;amp; implicature)：所谓含沙射影、话中带刺、指桑骂槐、拐弯抹角都是推理和隐喻的艺术。当然，推理和隐喻也可用于表达非负面的含义，这里就不展开描述。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;常见使用场景&quot;&gt;常见使用场景&lt;/h3&gt;
    
    </summary>
    
    
    
      <category term="system design" scheme="https://zhenghe-md.github.io/blog/tags/system-design/"/>
    
  </entry>
  
  <entry>
    <title>「Born a Crime」读后感</title>
    <link href="https://zhenghe-md.github.io/blog/2021/05/23/born-a-crime/"/>
    <id>https://zhenghe-md.github.io/blog/2021/05/23/born-a-crime/</id>
    <published>2021-05-23T09:04:37.000Z</published>
    <updated>2021-10-06T14:41:42.326Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;因为之前在 Youtube 和 B 站上零星地看了一些 Trevor Noah 的 stand-up 和 Daily Show，加上最近在 Palfish App 上与来自南非的老师学英语，我在大约四月中旬决定读一读「Born a Crime」这本书，书的内容本来并不多，但个人时间安排原因使得这个过程变得很长，直到昨天终于读完。&lt;/p&gt;
&lt;p&gt;「Born a Crime」记录了 Trevor Noah 在南非成长的经历，但它并不像一个传记，而是将成长中的事件按照主题串联，如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;母亲对耶稣的绝对信仰&lt;/li&gt;
&lt;li&gt;出生前后及幼年时期成长因为特殊肤色 (colored) 不得不面对的问题&lt;/li&gt;
&lt;li&gt;母亲的独立，父亲的神秘&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;💡 完整的梗概可以移步 &lt;a href=&quot;https://www.litcharts.com/lit/born-a-crime/summary&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt; 阅读&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为什么人们会喜欢这本书？Trevor 在这个访谈里给出了他的看法。&lt;/p&gt;
&lt;div class=&quot;video-container&quot;&gt;&lt;iframe src=&quot;https://www.youtube.com/embed/W79NnhLsosw&quot; frameborder=&quot;0&quot; loading=&quot;lazy&quot; allowfullscreen&gt;&lt;/iframe&gt;&lt;/div&gt;
&lt;p&gt;大概说的就是每个人在这本书的某一桥段都会找到共鸣。当然，这也是所有受欢迎内容的共同特点。&lt;/p&gt;
&lt;h2 id=&quot;语录及感受&quot;&gt;语录及感受&lt;/h2&gt;
&lt;p&gt;下面我想挑选书中一些我特别喜欢的话，分享给对此有兴趣的你，也算是对这本书以及花在阅读这本书上的时间一个交代。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;We tell people to follow their dreams, but you can only dream of what you can imagine, and, depending on where you come from, your imagination can be quite limited.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="readings" scheme="https://zhenghe-md.github.io/blog/categories/readings/"/>
    
    
  </entry>
  
  <entry>
    <title>代码搜索引擎：基础篇</title>
    <link href="https://zhenghe-md.github.io/blog/2021/05/09/search-engine-for-codes-fundamentals/"/>
    <id>https://zhenghe-md.github.io/blog/2021/05/09/search-engine-for-codes-fundamentals/</id>
    <published>2021-05-09T10:19:17.000Z</published>
    <updated>2021-10-06T14:41:42.354Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;完整调研报告请见我个人的 Notion &lt;a href=&quot;https://www.notion.so/Code-Search-Engine-e1391cd82b3e490aa05edabdf7ceacd7&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;笔记&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;引入&quot;&gt;0. 引入&lt;/h1&gt;
&lt;p&gt;最近，我们遇到了两个场景：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;负责基础服务的工程师想下线一个接口但不知道有哪些服务调用&lt;/li&gt;
&lt;li&gt;负责 APM 系统的工程师想知道任意 RPC 接口的所有上游调用方&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;仔细分析不难发现，二者的本质都在于「维护微服务间的静态依赖关系」。等等！在调用链追踪系统中，我们不是已经获得了接口级别的依赖关系吗？为什么不能直接用那边的数据？目前伴鱼调用链追踪系统中维护的依赖关系在三个方面无法满足上述需求：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;一些上古服务仍然在运行，但没有接入调用链追踪系统&lt;/li&gt;
&lt;li&gt;调用链追踪系统中维护的是「动态依赖关系」，即最近 N 天 (由 retention policy 决定) 捕获的调用关系&lt;/li&gt;
&lt;li&gt;调用链追踪系统中存储的是经采样策略过滤后的数据，可能存在漏采的情况&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;于是我们开始思考另一个方向：&lt;strong&gt;通过代码搜索引擎提取静态依赖关系&lt;/strong&gt;。恰好在 2020 Q4 末，我们将内部所有项目仓库从 Gerrit 迁移到了 Gitlab，为代码搜索引擎的落地铺平了道路。&lt;/p&gt;
&lt;p&gt;在下文中，我们将和大家分享代码搜索引擎的调研报告，期望能帮助读者了解代码搜索引擎如何工作。报告主要讨论以下话题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为什么做&lt;/li&gt;
&lt;li&gt;一般架构&lt;/li&gt;
&lt;li&gt;设计决定&lt;/li&gt;
&lt;li&gt;实现挑战&lt;/li&gt;
&lt;li&gt;开源项目&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;为什么做&quot;&gt;1. 为什么做&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="system design" scheme="https://zhenghe-md.github.io/blog/tags/system-design/"/>
    
  </entry>
  
  <entry>
    <title>调用链追踪系统在伴鱼：实践篇</title>
    <link href="https://zhenghe-md.github.io/blog/2021/03/04/implementing-tail-based-sampling/"/>
    <id>https://zhenghe-md.github.io/blog/2021/03/04/implementing-tail-based-sampling/</id>
    <published>2021-03-04T17:03:51.000Z</published>
    <updated>2021-10-06T14:41:42.350Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;此文同时发表在&lt;a href=&quot;https://tech.ipalfish.com/blog/2021/03/04/implementing-tail-based-sampling/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;伴鱼技术博客&lt;/a&gt;上&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 &lt;a href=&quot;https://zhenghe-md.github.io/blog/2020/12/20/design-dimensions-of-tracing-systems/&quot;&gt;理论篇&lt;/a&gt; 中，我们介绍了伴鱼在调用链追踪领域的调研工作，本篇继续介绍伴鱼的调用链追踪实践。在正式介绍前，简单交代一下背景：2015 年，在伴鱼服务端起步之时，技术团队就做出统一使用 Go 语言的决定。这个决定的影响主要体现在：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;内部基础设施无需做跨语言支持&lt;/li&gt;
&lt;li&gt;技术选型会有轻微的语言倾向&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;早期实践&quot;&gt;1. 早期实践&lt;/h2&gt;
&lt;h3 id=&quot;对接-jaeger&quot;&gt;1.1 对接 Jaeger&lt;/h3&gt;
&lt;p&gt;2019 年，公司内部的微服务数量逐步增加，调用关系日趋复杂，工程师做性能分析、问题排查的难度变大。这时亟需一套调用链追踪系统帮助我们增强对服务端全貌的了解。经过调研后，我们决定采用同样基于 Go 语言搭建的、由 CNCF 孵化的项目 &lt;a href=&quot;https://www.jaegertracing.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Jaeger&lt;/a&gt;。当时，服务的开发和治理都尚未引入 &lt;code&gt;context&lt;/code&gt;，不论进程内部调用还是跨进程调用，都没有上下文传递。因此早期引入调用链追踪的工作重心就落在了服务及服务治理框架的改造，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 HTTP、Thrift 和 gRPC 的服务端和客户端注入上下文信息&lt;/li&gt;
&lt;li&gt;在数据库、缓存、消息队列的接入点上埋点&lt;/li&gt;
&lt;li&gt;快速往既有项目仓库中注入 &lt;code&gt;context&lt;/code&gt; 的命令行工具&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;部署方面：测试环境采用 &lt;strong&gt;all-in-one&lt;/strong&gt;，线上环境采用 &lt;a href=&quot;https://www.jaegertracing.io/docs/1.22/architecture/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;direct-to-storage&lt;/strong&gt;&lt;/a&gt; 方案。整个过程前后大约耗时一个月，我们在 2019 年 Q3 上线了第一版调用链追踪系统。配合广泛被采用的 prometheus + grafana 以及 ELK，我们在微服务群的可观测性上终于凑齐了调用链 (traces)、日志 (logs) 和监控指标 (metrics) 三个要素。&lt;/p&gt;
&lt;p&gt;下图是第一版调用链追踪系统的数据上报通路示意图。服务运行在容器中，通过 opentracing 的 sdk 埋点，Jaeger 的 go-sdk 上报到宿主机上的 Jaeger-agent，后者再将数据进一步上报到 Jaeger-collector，最终将调用链数据写入 ES，建立索引，即图中的 Jaeger backends。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./distributed-tracing-v1.png&quot; alt=&quot;distributed-tracing-v1&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="system design" scheme="https://zhenghe-md.github.io/blog/categories/system-design/"/>
    
    
  </entry>
  
  <entry>
    <title>调用链追踪系统的设计维度</title>
    <link href="https://zhenghe-md.github.io/blog/2020/12/20/design-dimensions-of-tracing-systems/"/>
    <id>https://zhenghe-md.github.io/blog/2020/12/20/design-dimensions-of-tracing-systems/</id>
    <published>2020-12-20T23:03:14.000Z</published>
    <updated>2021-10-06T14:41:42.326Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;tldr&quot;&gt;TL;DR&lt;/h1&gt;
&lt;p&gt;本文将调用链追踪系统的设计维度归结于以下 5 个：调用链数据模型、元数据结构、因果关系、采样策略以及数据可视化。我们可以把这 5 个维度当作一个分析框架，用它帮助我们在理论上解构市面上任意一个调用链追踪系统，在实践中根据使用场景进行技术选型和系统设计。如果你对调研相关系统很感兴趣，也欢迎参与到 &lt;a href=&quot;https://github.com/ZhengHe-MD/database-of-tracing-systems&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Database of Tracing Systems&lt;/a&gt; 项目中，一起调研市面上的项目，建立起调用链追踪系统的数据库。&lt;/p&gt;
&lt;h1 id=&quot;引言&quot;&gt;引言&lt;/h1&gt;
&lt;p&gt;阅读本文并不要求读者具备任何调用链追踪系统相关的理论知识或实践经验，读者具备一定的微服务架构的概念或实践经验即可。期望读者看完这篇文章以后，能掌握调用链追踪系统的核心设计维度，理解其中的设计权衡，并能使用这些维度来分析市面上的新老调用链追踪系统实现，甚至帮助到自己在生产实践中根据使用场景进行技术选型和系统设计。&lt;/p&gt;
&lt;h1 id=&quot;解决的问题&quot;&gt;解决的问题&lt;/h1&gt;
&lt;h2 id=&quot;微服务的可观测性&quot;&gt;微服务的可观测性&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Any organization that designs a system (defined broadly) will produce a design whose structure is a copy of the organization&#39;s communication structure.&lt;/p&gt;
&lt;p&gt;— Melvin E. Conway&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果有一门学科叫软件社会学，那么康威定律 (Conway&#39;s law) 必定是其中的基本定律之一。如果把互联网公司内部的全体信息系统看作是一整个系统，那么这个系统模块结构会向公司的组织架构收敛。从组织架构层面看，公司结构从扁平向多层级演变，信息传递的环节增加，沟通效率随之下降，进而影响公司的行动效率。不论从组员之间的熟悉程度还是从部门目标一致性来看，部门内部的沟通效率要远远高于部门间的沟通效率。因此，如果系统模块结构与组织架构约趋近，公司的沟通效率就能接近极大值。团队的分化通常伴随着服务的拆分，这也是许多公司业务增长以后进行微服务化的动机。微服务化后，公司信息系统就被迫成为了分布式系统。尽管分布式系统带来了种种好处，如持续集成、增量部署、横向扩展、故障隔离，但系统可观测性比起单机系统下降了很多，甚至几乎没有人能够对公司信息系统有全局性的了解。&lt;/p&gt;
&lt;p&gt;任意一个分布式系统的终极理想是：“给开发者以分布式的能力，单机的感受”。而调用链追踪系统就是实现终极理想不可或缺的一部分。调用链追踪系统通过收集调用链数据，帮助开发者在观测分布式系统行为时，从以机器为中心 (machine-centric) 走向以请求为中心 (workflow-centric)。调用链 (traces)、日志 (logs)、监控指标 (metrics)，三者合称 Telemetry，有了它们，微服务开发者既能通盘考虑，又能深入局部分析，在系统规模扩大的同时仍然能够掌控全局。&lt;/p&gt;
&lt;h2 id=&quot;使用场景&quot;&gt;使用场景&lt;/h2&gt;
    
    </summary>
    
    
      <category term="system design" scheme="https://zhenghe-md.github.io/blog/categories/system-design/"/>
    
    
      <category term="distributed tracing" scheme="https://zhenghe-md.github.io/blog/tags/distributed-tracing/"/>
    
      <category term="distributed system" scheme="https://zhenghe-md.github.io/blog/tags/distributed-system/"/>
    
  </entry>
  
  <entry>
    <title>So, you want to trace your distributed system? Key design insights from years of practical experience (2014)</title>
    <link href="https://zhenghe-md.github.io/blog/2020/11/29/so-you-want-to-trace-your-distributed-system-key-design-insights-from-years-of-practical-experience/"/>
    <id>https://zhenghe-md.github.io/blog/2020/11/29/so-you-want-to-trace-your-distributed-system-key-design-insights-from-years-of-practical-experience/</id>
    <published>2020-11-29T21:28:32.000Z</published>
    <updated>2021-10-06T14:41:42.362Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;按：本文会尊从原论文的结构，但不是逐字翻译，以意译和加入个人理解的转述为主。&lt;/p&gt;
&lt;h1 id=&quot;introduction&quot;&gt;1. Introduction&lt;/h1&gt;
&lt;p&gt;如果把公司内部所有 IT 系统看作一个巨型分布式系统，通常其规模庞大、结构复杂，且拥有多层依赖和抽象，每层单拎出来也同样是个分布式系统。以 Google 的业务服务为例，如搜索、广告，会构建于内部基础服务之上，如 Bigtable；而 BigTable 又构建于 Google File System (GFS) 和 Chubby 之上。即便是业务服务本身，也可能存在多层 (multiple tiers) 结构，其中每层同样支持横向扩展。从巨石应用走向微服务，我们在组织架构和服务架构上都变得高效，但其代价就是下降的系统可观测性 (observability)。一个很现实的问题就是：几乎不存在一位工程师能够了解系统全貌，那么问题排查也将变得困难。从单机走向分布式，只关心单个进程、单台机器的性能指标已经远远不够，我们需要将监控的重心从以机器为中心 (machine-centric) 转向以流程为中心 (workflow-centric)，后者的核心方法便是调用链追踪系统。分布式系统的终极理想可以描述为：在获得横向扩展性的同时不暴露自己分布式的本质，即向外提供与单机系统相同的体验。调用链追踪系统概莫能外。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;按：原文将请求处理过程称为 workflow，下文会使用流程和请求来指代它；原文将以流程为中心的观测方法统称为 end-to-end tracing，由于现在分布式系统几乎是所有讨论的默认假设，本文将不再强调 end-to-end，将其直接译为调用链追踪。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;尽管大家对调用链追踪的兴趣浓厚，但关于如何设计一个调用链追踪系统，市面上、社区中提供的信息十分有限。更令人担忧的是，现存的文献和实践都将调用链追踪当作多种场景的万能解决方案 (one-size-fits-all)，然而我们以及 Dapper 的实践经验证明事实并非如此。因此在提出你的解决方案之前，最好明确你想要解决的问题是什么。&lt;/p&gt;
&lt;p&gt;调用链追踪的基本原理和概念十分通俗易懂：就是在系统中的各个节点 (组件) 上埋点，当请求经过时将节点信息 (trace point) 上报，最后汇总信息重建调用链。我们从经验中总结了调用链追踪系统的 4 个设计维度，通过组合这些设计维度的选择就能得到不同应用场景的解决方案：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;which causal relationships should be preserved: 保留什么样的因果关系？&lt;/li&gt;
&lt;li&gt;how causal relationships are tracked: 如何追踪因果关系？&lt;/li&gt;
&lt;li&gt;how to reduce overhead by sampling: 如何通过采样降低成本？&lt;/li&gt;
&lt;li&gt;how end-to-end traces should be visualized: 如何将追踪的结果可视化？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果对这 4 个设计维度以及它们之间的权衡关系没有足够的理解，设计一个调用链追踪系统将可能让实现与场景脱节。事实上，由于这些维度之前并未被实践者或研究者提出和充分理解，许多调用链追踪系统的实现并未能充分达成其设计理想。&lt;/p&gt;
&lt;h1 id=&quot;backgroud&quot;&gt;2. Backgroud&lt;/h1&gt;
&lt;p&gt;本节主要陈述一些调用链追踪系统的背景信息，包括核心应用场景、解决方案分类以及本文所推崇的架构方案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="papers-we-love" scheme="https://zhenghe-md.github.io/blog/categories/papers-we-love/"/>
    
    
      <category term="distributed tracing" scheme="https://zhenghe-md.github.io/blog/tags/distributed-tracing/"/>
    
      <category term="distributed system" scheme="https://zhenghe-md.github.io/blog/tags/distributed-system/"/>
    
      <category term="system design" scheme="https://zhenghe-md.github.io/blog/tags/system-design/"/>
    
  </entry>
  
  <entry>
    <title>Go Error Handling 方案调研</title>
    <link href="https://zhenghe-md.github.io/blog/2020/10/05/Go-Error-Handling-Research/"/>
    <id>https://zhenghe-md.github.io/blog/2020/10/05/Go-Error-Handling-Research/</id>
    <published>2020-10-05T16:20:00.000Z</published>
    <updated>2021-10-06T14:41:42.294Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;自从 2018 年底用 Go 搭建第一个项目以来，已经过去接近 2 年时间，我发现自己从未系统地思考过 Go 的 error handling 方案。最近在阅读 [1] 时，逐渐发现个人和团队都应该花更多的精力建立更加扎实的工程实践方法论，进一步提升交付项目质量。而本篇博客算是向这个方向迈出的第一步。&lt;/p&gt;
&lt;h2 id=&quot;术语说明&quot;&gt;0. 术语说明&lt;/h2&gt;
&lt;p&gt;为了避免翻译造成的歧义，文中涉及的没有通用翻译中文的术语都会直接使用原英文单词：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&quot;header&quot;&gt;
&lt;th&gt;英文&lt;/th&gt;
&lt;th&gt;中文&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td&gt;error&lt;/td&gt;
&lt;td&gt;错误&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td&gt;exception&lt;/td&gt;
&lt;td&gt;异常&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td&gt;error-code-based&lt;/td&gt;
&lt;td&gt;基于错误码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td&gt;exception-based&lt;/td&gt;
&lt;td&gt;基于异常&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td&gt;package&lt;/td&gt;
&lt;td&gt;包 (Go 中 module 由多个 package 构成)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td&gt;error wrapping/unwrapping&lt;/td&gt;
&lt;td&gt;包装错误/解包装&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td&gt;error inspection&lt;/td&gt;
&lt;td&gt;错误检查&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td&gt;error formatting&lt;/td&gt;
&lt;td&gt;错误格式化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td&gt;error chain&lt;/td&gt;
&lt;td&gt;错误链表，即通过包装将错误组织成链表结构&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td&gt;error class&lt;/td&gt;
&lt;td&gt;错误类别、类型&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;下文中，errors package 指代我们定制化的 error handling 方案。&lt;/p&gt;
&lt;h2 id=&quot;文献综述&quot;&gt;1. 文献综述&lt;/h2&gt;
&lt;p&gt;不同程序语言的 error handling 方案大致可以分为两种：error-code-based 和 exception-based。Raymond 在博客 [2] [3] 中指出 exception-based 错误处理更不利于写出优质的代码，也更难辨别优质和劣质的代码；Go 在设计时选择了 error-code-based error handling 方案，鼓励开发者显式地在 error 出现的地方直接处理 [4]；并在官博 [5] 中提出了 &lt;strong&gt;errors are values&lt;/strong&gt; 的理念，只要实现 &lt;code&gt;Error&lt;/code&gt; 接口的结构体就可以作为 error，不同的项目就能够按需定制 error handling 实现方案，并提出在一些特殊场景下可以利用非通用的代码重构技巧避免冗长、啰嗦的表达，如errWriter；许多来自 Java、Python 等语言的工程师习惯了 exception-based 的方案，遇到 Go 时感到十分不习惯 [6]，但如果我们总是希望在一门新语言中尝试套用自己熟悉语言的语法，就无法充分理解其它语言在这方面的设计理念。Go 核心工程师 Rob Pike 在 [7] 中描述了他如何在 &lt;a href=&quot;https://upspin.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Upspin&lt;/a&gt; 项目中定制 error 信息和处理方案，使得项目对程序、用户及开发者更加友好；许多 error handling 项目都关注到了多层嵌套调用场景下的上下文注入问题，即所谓的 error wrapping，其中 Dave Cheney 的项目 pkg/errors [8] 被广泛使用，Go 在 1.13 后也提供类似的原生解决方案 [9]；受 [7] [8] 的启发，Ben Johnson，boltDB 的作者，结合自己多年的编码经验，在 [10] 中提出 &lt;strong&gt;Failure is your Domain&lt;/strong&gt; 的观点，认为每个项目应当构建特有的 error handling package，并提出逻辑调用栈 (logical stack) 的概念，在 GopherCon 2019，还有工程师在推广类似的方案 [11]。&lt;/p&gt;
&lt;p&gt;error handling 可以细分为 checking、inspection 和 formatting 三部分，分别指判断 error 发生与否、检查 error 类型、打印 error 上下文。在发现 Go 社区的开发者们因为语言本身对 error handling 的支持不足，频繁创造各种各样的轮子之后，Russ Cox 在 2018 年末发布了两个新提议 [12] [13]，前者尝试解决 checking 代码冗长的问题；后者尝试解决 inspection 的信息丢失以及 formatting 的上下文信息不足问题。目前仅 inspection 的方案被整合到了 1.13 中，直到最近的 1.15 版本没有新的解决方案出现。&lt;/p&gt;
&lt;h2 id=&quot;项目综述&quot;&gt;2. 项目综述&lt;/h2&gt;
&lt;p&gt;发布之初，Go (&amp;lt;1.13) 仅提供 &lt;code&gt;Error&lt;/code&gt; 接口及 &lt;code&gt;errors.New&lt;/code&gt;、&lt;code&gt;fmt.Errorf&lt;/code&gt; 两个构建 error 的方法 [4]；Go 1.13 支持利用 &lt;code&gt;%w&lt;/code&gt; 格式化符号实现 error wrapping，并提供 &lt;code&gt;Unwrap&lt;/code&gt;、&lt;code&gt;errors.Is&lt;/code&gt; 以及 &lt;code&gt;errors.As&lt;/code&gt; 来解决 error wrapping 过程中上下文缺失的问题 [9]；spacemonkeygo 为了将大型 Python 仓库迁移到 Go 上，开发了 [14] ，模拟 Python 中 error class 的继承，支持自动记录日志、调用栈以及任意键值数据，支持 error inspection；juju errors [15] 因 juju 项目而诞生，在 wrap error 时，你可以选择保留或隐藏 error 产生的原因 (cause)，但它的 &lt;code&gt;Cause&lt;/code&gt; 方法仅 unwrap 一层，而 [8] 会递归地遍历 error chain，[16] 中的概念与 [15] 类似，仅在 API 上有所不同；hashicorp 开源的 errwrap [16]，支持将 errors 组织成树状结构，并提供 &lt;code&gt;Walk&lt;/code&gt; 方法遍历这棵树；pkg/errors [8] 提供 wrapping 和调用栈捕获的功能，并利用 &lt;code&gt;%+v&lt;/code&gt; 格式化 error，展示更多的细节，它认为只有整个 error chain 最末端的 error 最有价值，pingcap/errors [18] 基于 [8] 二次开发，并且在 [19] 中增加了 error 类 (域) 的概念；upspin.io/errors [20] 是定制化 error 的实践范本，同时引入了 &lt;code&gt;errors.Is&lt;/code&gt; 和 &lt;code&gt;errors.Match&lt;/code&gt; 用于辅助检查 error 类型；[21] 考虑了 error 在进程间传递的场景，让 error handling 具备网络传播兼容能力。&lt;/p&gt;
    
    </summary>
    
    
      <category term="engineering" scheme="https://zhenghe-md.github.io/blog/categories/engineering/"/>
    
    
      <category term="Go" scheme="https://zhenghe-md.github.io/blog/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Apache Arrow 小结</title>
    <link href="https://zhenghe-md.github.io/blog/2020/09/20/apache-arrow-summary/"/>
    <id>https://zhenghe-md.github.io/blog/2020/09/20/apache-arrow-summary/</id>
    <published>2020-09-20T21:14:48.000Z</published>
    <updated>2021-10-06T14:41:42.326Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;最近在阅读 TiDB 源码 util/chunk package 的过程中，看到了 Apache Arrow 这个项目 (下文简称 Arrow)：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Chunk stores multiple rows of data in Apache Arrow format.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// See https://arrow.apache.org/docs/format/Columnar.html#physical-memory-layout&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Values are appended in compact format and can be directly accessed without decoding.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// When the chunk is done processing, we can reuse the allocated memory by resetting it.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; Chunk &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &amp;#123; &lt;span class=&quot;comment&quot;&gt;/*...*/&lt;/span&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;心里自然而然会产生疑问：为什么要使用这个项目规定的数据存储格式？于是在阅读完 TiDB 相关源码和单测后，顺便搜寻并浏览一些有趣的资料 (见文末参考部分)，现在将这次调研的收获小结在这篇博客中。&lt;/p&gt;
&lt;p&gt;本文简单地介绍一种内存列存数据格式：Apache Arrow，主要涉及的内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Arrow 项目的来源&lt;/li&gt;
&lt;li&gt;Arrow 如何表示定长、变长和嵌套数据&lt;/li&gt;
&lt;li&gt;内存列存数据格式与磁盘列存数据格式的设计取舍&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注：Arrow 即可以指内存列存数据格式，也可以指 Apache Arrow 项目整体，因此下文中将用 「Arrow」 表示格式本身，「Arrow 项目」表示整体项目。&lt;/p&gt;
&lt;h2 id=&quot;项目简介&quot;&gt;项目简介&lt;/h2&gt;
&lt;p&gt;现存的大数据分析系统基本都基于各自不同的内存数据结构，这就会带来一系列的重复工作：从计算引擎上看，算法必须基于项目特有的数据结构、API 与算法之间出现不必要的耦合；从数据获取上看，数据加载时必须反序列化，而每一种数据源都需要单独实现相应的加载器；从生态系统上看，跨项目、跨语言的合作无形之中被阻隔。能否减少或消除数据在不同系统间序列化、反序列化的成本？能否跨项目复用算法及 IO 工具？能否推动更广义的合作，让数据分析系统的开发者联合起来？在这样的使命驱动下，Arrow 就诞生了。&lt;/p&gt;
&lt;p&gt;与其它项目不同，Arrow 项目的草台班子由 5 个 Apache Members、6 个 PMC Chairs 和一些其它项目的 PMC 及 committer 构成，他们直接找到 ASF 董事会，征得同意后直接以顶级 Apache 项目身份启动。想了解项目的详细历史可以阅读项目 Chair，Jacques Nadeau 写的这篇&lt;a href=&quot;https://www.dremio.com/origin-history-of-apache-arrow/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;博客&lt;/a&gt;。另外，这张 &lt;a href=&quot;https://docs.google.com/spreadsheets/d/1q6UqluW6SLuMKRwW2TBGBzHfYLlXYm37eKJlIxWQGQM/edit#gid=0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;google sheet&lt;/a&gt; 记录着项目的取名过程，取名为 Arrow 的原因是：&quot;math symbol for vector. and arrows are fast. also alphabetically will show up on top.&quot; 可以说考虑得相当全面 😂。&lt;/p&gt;
&lt;p&gt;Arrow 的愿景是提供内存数据分析 (in-memory analytics) 的开发平台，让数据在异构大数据系统间移动、处理地更快：&lt;/p&gt;
    
    </summary>
    
    
      <category term="system design" scheme="https://zhenghe-md.github.io/blog/categories/system-design/"/>
    
    
      <category term="database" scheme="https://zhenghe-md.github.io/blog/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>The Anatomy of a Large-Scale Hypertextual Web Search Engine (1998)</title>
    <link href="https://zhenghe-md.github.io/blog/2020/07/21/the-anatomy-of-a-large-scale-hypertextual-web-search-engine-1998/"/>
    <id>https://zhenghe-md.github.io/blog/2020/07/21/the-anatomy-of-a-large-scale-hypertextual-web-search-engine-1998/</id>
    <published>2020-07-21T23:35:09.000Z</published>
    <updated>2021-10-06T14:41:42.366Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;最近因为工作的关系接触 ElasticSearch，发现搜索引擎也是计算机应用的一个有意思的分支。于是通过 Freiburg 的 Information Retrieval 公开课开始系统地了解信息检索这个领域，感觉收获颇丰。周末一时兴起，上 Google Research 找到了 Google 的开山之作，近距离地感受一下 19800+ 引用量、造就如今 Google 万亿市值的这篇文章。&lt;/p&gt;
&lt;p&gt;本文介绍会尽可能地忠于原文，但不是完全逐字逐句的翻译。&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;1. 简介&lt;/h2&gt;
&lt;p&gt;近年来，网络中的信息量和非专业的用户都在快速增长，为信息检索领域带来了新的挑战。从行为上看，人们更倾向于以门户网站，如 Yahoo，或搜索引擎为起点，利用网页间的链接来浏览所需信息。门户网站的索引来自于人工维护，聚合效果好、主观性高、维护成本高、改进速度慢，且通常不会覆盖小众话题。自动化的搜索引擎则相反，其它都满足，但聚合效果差，依赖于关键词匹配的检索方式返回的匹配项质量过低。一些广告商为了获取更多的流量，通过逆向工程来误导搜索引擎，使其结果靠前，进一步加剧问题的严重性。我们搭建了一个大型搜索引擎来当前系统的这些已知问题，它通过重度利用网页文本中的特殊结构来提供更高质量的检索结果。&lt;strong&gt;我们为这个系统取名为 Google，因为它是 googol (即 &lt;span class=&quot;math inline&quot;&gt;&lt;mjx-container class=&quot;MathJax&quot; jax=&quot;SVG&quot;&gt;&lt;svg style=&quot;vertical-align: -0.05ex&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;4.775ex&quot; height=&quot;2.005ex&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewBox=&quot;0 -864 2110.7 886&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;msup&quot;&gt;&lt;g data-mml-node=&quot;mn&quot;&gt;&lt;use xlink:href=&quot;#MJX-TEX-N-31&quot;/&gt;&lt;use xlink:href=&quot;#MJX-TEX-N-30&quot; transform=&quot;translate(500, 0)&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; transform=&quot;translate(1000, 393.1) scale(0.707)&quot; data-mjx-texclass=&quot;ORD&quot;&gt;&lt;g data-mml-node=&quot;mn&quot;&gt;&lt;use xlink:href=&quot;#MJX-TEX-N-31&quot;/&gt;&lt;use xlink:href=&quot;#MJX-TEX-N-30&quot; transform=&quot;translate(500, 0)&quot;/&gt;&lt;use xlink:href=&quot;#MJX-TEX-N-30&quot; transform=&quot;translate(1000, 0)&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/mjx-container&gt;&lt;/span&gt; ) 的常用拼写，后者的含义恰好与构建大型搜索引擎的目标体量相契合&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;网络搜索引擎的扩张1994---2000&quot;&gt;网络搜索引擎的扩张：1994 - 2000&lt;/h3&gt;
&lt;p&gt;为了跟上网络信息扩张的速度，搜索引擎技术也必须加速规模化。1994 年，World Wide Web Worm (WWWW)，第一代网络搜索引擎 (web search engine) 之一，对 11 万网页或文件建立了索引；到了 1997 年末，行业领先的网络搜索引擎建立索引的数量已达到 200 万 (WebCrawler)，甚至 1 亿 (Search Engine Watch)。可以预见这个数量在 2000 年将超过 10 亿。与此同时，网络上的搜索引擎处理的查询也在飞速增长。在 1994 年初，WWWW 大约每日需要处理 1500 次查询，到了 1997 年末，Altavista 已经声称自己每日处理的请求量达到 2 千万。同样可以预见，这个数量在 2000 年也将达到亿级。Google 的目标就是要提供相应规模、高质量的网络搜索服务。&lt;/p&gt;
&lt;h3 id=&quot;google-与网络一同扩张&quot;&gt;Google: 与网络一同扩张&lt;/h3&gt;
&lt;p&gt;即便是搭建一个满足当前规模的网络搜索引擎也需要面对许多挑战，如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高性能的网页抓取技术保证原始数据全而新&lt;/li&gt;
&lt;li&gt;充足的存储空间用以存放索引和网页本身 (如果需要的话)&lt;/li&gt;
&lt;li&gt;索引系统必须能够高效地处理百 G 级别的数据&lt;/li&gt;
&lt;li&gt;查询必须能被快速处理，QPS 过千&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="papers-we-love" scheme="https://zhenghe-md.github.io/blog/categories/papers-we-love/"/>
    
    
  </entry>
  
  <entry>
    <title>I ❤ Logs 小结</title>
    <link href="https://zhenghe-md.github.io/blog/2020/07/12/I-%E2%9D%A4-Logs-%E5%B0%8F%E7%BB%93/"/>
    <id>https://zhenghe-md.github.io/blog/2020/07/12/I-%E2%9D%A4-Logs-%E5%B0%8F%E7%BB%93/</id>
    <published>2020-07-12T18:06:15.000Z</published>
    <updated>2021-10-06T14:41:42.294Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;I ❤ Logs&lt;/em&gt; 出版于 2014 年，是一本很短小的书，100 页不到，利用这周的零散时间就看完了。作者 &lt;a href=&quot;https://www.linkedin.com/in/jaykreps/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Jay Kreps&lt;/a&gt;，是前 LinkedIn 的 Principal Staff Engineer，也是 LinkedIn 许多著名开源项目的负责人及联合作者，如 Kafka、Voldemort 等。他是现任 &lt;a href=&quot;https://www.confluent.io/about/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Confluent&lt;/a&gt; 的 CEO，主要工作在于围绕实时数据提供企业级服务支持。这本书算是 Jay Kreps 过去多年实践的思考结晶。&lt;/p&gt;
&lt;p&gt;本文主要是对书中的一些看法、观点的个人化梳理，有兴趣可以阅读&lt;a href=&quot;https://www.confluent.io/ebook/i-heart-logs-event-data-stream-processing-and-data-integration/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原著&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;日志即数据&quot;&gt;日志即数据&lt;/h2&gt;
&lt;p&gt;在讨论日志之前，首先要明确日志的含义。这里的日志并非指我们常用的非结构化或半结构化的服务日志，而更接近数据库中常见的结构化的提交日志 (commit log/journal/WAL)，这些日志通常是只往后追加数据，这里的序号暗含着逻辑时间，标识着连续日志产生的逻辑先后顺序：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/blog/2020/07/12/I-❤-Logs-小结/a-structured-log.jpg&quot; alt=&quot;a-structured-log&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;数据库中的日志&quot;&gt;数据库中的日志&lt;/h3&gt;
&lt;p&gt;日志在数据库中常常被用来实现故障恢复、数据复制、最终一致性等。一个事务提交成功与否在日志提交成功时就可以确定，只要 WAL 落盘，便可告诉客户端提交成功，即便数据库发生故障，也能从 WAL 日志中恢复数据；日志 (如 BinLog) 的 pub/sub 机制可以用来在主节点与复制节点之间同步数据，通过同步的进度可以知道不同复制节点的同步进度，此外日志的逻辑顺序保证了主节点与复制节点之间数据的一致性。&lt;/p&gt;
&lt;h3 id=&quot;分布式系统中的日志&quot;&gt;分布式系统中的日志&lt;/h3&gt;
&lt;p&gt;数据库利用日志来解决的问题，也是所有分布式系统需要解决的根本问题，如刚才提到的故障恢复、数据同步、数据一致性等等，可以称之为以日志为中心 (log-centric) 的解决方案。更严谨地说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果两个相同的 (identical)、确定 (deterministic) 的进程以相同的状态启动，按相同的顺序获取相同的输入，它们将最终达到相同的状态。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="books-we-love" scheme="https://zhenghe-md.github.io/blog/categories/books-we-love/"/>
    
    
  </entry>
  
  <entry>
    <title>Jaeger Walkthrough: jaeger-client-go</title>
    <link href="https://zhenghe-md.github.io/blog/2020/06/21/Jaeger-Walkthrough-jaeger-client-go/"/>
    <id>https://zhenghe-md.github.io/blog/2020/06/21/Jaeger-Walkthrough-jaeger-client-go/</id>
    <published>2020-06-21T22:28:35.000Z</published>
    <updated>2021-10-06T14:41:42.302Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Jaeger Walkthrough 系列文章之一，旨在深入理解 Jaeger 项目内部的实现细节。本文介绍的是 Jaeger 的 Go 客户端，&lt;a href=&quot;https://github.com/jaegertracing/jaeger-client-go/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;jaeger-client-go&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;jaeger-client-go 是 Jaeger 对 opentracing-go 标准接口的实现，主要解决的是两个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何在进程内部管理调用链追踪信息 (tracer, span)&lt;/li&gt;
&lt;li&gt;如何在进程间传递调用链追踪信息 (span context, propagation)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但在调用链追踪实践中，jaeger-client-go 仅仅解决上述两个问题还不够，它还需要考虑的问题包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何将数据上报到存储中心&lt;/li&gt;
&lt;li&gt;如何对数据抽样，支持不同的抽样策略&lt;/li&gt;
&lt;li&gt;需要收集哪些统计指标&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来，我们就着源码对这些问题一一分析。&lt;/p&gt;
&lt;h2 id=&quot;进程内调用链追踪信息管理&quot;&gt;进程内调用链追踪信息管理&lt;/h2&gt;
&lt;h3 id=&quot;tracer&quot;&gt;Tracer&lt;/h3&gt;
&lt;p&gt;Tracer 是 opentracing.Tracer 的实现，它负责与应用程序沟通，接收应用程序的请求，协调 jaeger-client-go 中各个模块完成相应工作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="open source project" scheme="https://zhenghe-md.github.io/blog/categories/open-source-project/"/>
    
    
  </entry>
  
  <entry>
    <title>Prometheus Alertmanager Walkthrough</title>
    <link href="https://zhenghe-md.github.io/blog/2020/06/13/Understanding-Prometheus-Alertmanager/"/>
    <id>https://zhenghe-md.github.io/blog/2020/06/13/Understanding-Prometheus-Alertmanager/</id>
    <published>2020-06-13T22:21:27.000Z</published>
    <updated>2021-10-06T14:41:42.322Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Alertmanager 是 Prometheus 提供的报警分发平台，它主要满足的是报警的路由、分组、抑制、去重等常见需求。&lt;/p&gt;
&lt;h2 id=&quot;整体报警控制逻辑&quot;&gt;整体报警控制逻辑&lt;/h2&gt;
&lt;p&gt;Alertmanager 将报警路由组织成树状结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/blog/2020/06/13/Understanding-Prometheus-Alertmanager/route-tree.jpg&quot; alt=&quot;route-tree&quot;&gt;&lt;/p&gt;
&lt;p&gt;每条报警信息进入 Alertmanager 后，都会被流转给根路由，然后根据每个路由的配置决定是否递归地继续往下传播。每条报警信息最终都会匹配到一棵路由子树，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/blog/2020/06/13/Understanding-Prometheus-Alertmanager/route-tree-matched.jpg&quot; alt=&quot;route-tree-matched&quot;&gt;&lt;/p&gt;
&lt;p&gt;这棵子树上的路由就是可能发出报警信息的路由。那么报警信息在单个路由内部是如何处理的？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/blog/2020/06/13/Understanding-Prometheus-Alertmanager/route.jpg&quot; alt=&quot;routed&quot;&gt;&lt;/p&gt;
&lt;p&gt;每个路由内部会有一组匹配器 (Matcher) 负责匹配报警信息，匹配成功则表示路由命中。进入路由内部后，会根据报警信息的一些特征将其分配到某个特定的组 (Group)，每个组内拥有独立的通知 (Notify) 处理逻辑，如抑制、冷却、去重，最终满足一定条件后，路由会根据接收人 (Receiver) 配置，将报警信息通过通知媒介传递给相应的负责人。&lt;/p&gt;
&lt;h2 id=&quot;项目架构&quot;&gt;项目架构&lt;/h2&gt;
    
    </summary>
    
    
      <category term="open source project" scheme="https://zhenghe-md.github.io/blog/categories/open-source-project/"/>
    
    
  </entry>
  
  <entry>
    <title>The Most Beautiful Program Ever Written</title>
    <link href="https://zhenghe-md.github.io/blog/2020/06/07/The-Most-Beautiful-Program-Ever-Written/"/>
    <id>https://zhenghe-md.github.io/blog/2020/06/07/The-Most-Beautiful-Program-Ever-Written/</id>
    <published>2020-06-07T10:04:15.000Z</published>
    <updated>2021-10-06T14:41:42.322Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;本文来自于 2017 年 PWL NYC Meetup，作者的简介如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;William E. Byrd (&lt;span class=&quot;citation&quot; data-cites=&quot;webyrd&quot;&gt;@webyrd&lt;/span&gt;) is a Research Assistant Professor in the School of Computing at the University of Utah. He is co-author of &#39;The Reasoned Schemer&#39;, and is co-designer of the miniKanren relational programming language. He loves StarCraft (BW &amp;amp; SC2). Ask him about the scanning tunneling microscope (STM) he is building.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先假设你已经对 Scheme (Lisp 的一门方言) 的基本语法有一些了解。我们直奔主题，来看这个 &quot;The Most Beautiful Program Ever Written&quot; 究竟是什么程序。&lt;/p&gt;
&lt;h2 id=&quot;a-lisp-interpreter-written-in-lisp&quot;&gt;A Lisp interpreter written in Lisp&lt;/h2&gt;
&lt;p&gt;这个 List interpreter 的核心代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight scheme&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;define&lt;/span&gt;&lt;/span&gt; eval-expr&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;lambda&lt;/span&gt;&lt;/span&gt; (expr env)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    (&lt;span class=&quot;name&quot;&gt;pmatch&lt;/span&gt; expr&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [,x (&lt;span class=&quot;name&quot;&gt;guard&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;symbol?&lt;/span&gt;&lt;/span&gt; x))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                (&lt;span class=&quot;name&quot;&gt;env&lt;/span&gt; x)]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;lambda&lt;/span&gt;&lt;/span&gt; (,x) ,body)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;lambda&lt;/span&gt;&lt;/span&gt; (arg)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               (&lt;span class=&quot;name&quot;&gt;eval-expr&lt;/span&gt; body (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;lambda&lt;/span&gt;&lt;/span&gt; (y)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                 (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;if&lt;/span&gt;&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;eq?&lt;/span&gt;&lt;/span&gt; x y)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                     arg&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                     (&lt;span class=&quot;name&quot;&gt;env&lt;/span&gt; y)))))]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [(,rator ,rand)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             ((&lt;span class=&quot;name&quot;&gt;eval-expr&lt;/span&gt; rator env)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              (&lt;span class=&quot;name&quot;&gt;eval-expr&lt;/span&gt; rand env))])))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;pmatch 中仅用短短 3 行代码，就实现了 List interpreter 核心流程，它是如何做到的？&lt;/p&gt;
&lt;h3 id=&quot;pmatch&quot;&gt;pmatch&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;pmatch&lt;/code&gt; 是一个 &lt;code&gt;pattern match&lt;/code&gt; 工具包，用于匹配输入的文本，如：&lt;/p&gt;
&lt;figure class=&quot;highlight scheme&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[(,rator ,rand)]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="papers-we-love" scheme="https://zhenghe-md.github.io/blog/tags/papers-we-love/"/>
    
  </entry>
  
  <entry>
    <title>报警平台的匹配器演进</title>
    <link href="https://zhenghe-md.github.io/blog/2020/05/10/The-Evolution-of-Alertmanager-Matcher-in-Palfish/"/>
    <id>https://zhenghe-md.github.io/blog/2020/05/10/The-Evolution-of-Alertmanager-Matcher-in-Palfish/</id>
    <published>2020-05-10T00:00:00.000Z</published>
    <updated>2021-10-06T14:41:42.318Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;本文介绍伴鱼内部服务报警平台中匹配器模块的演进，及其利用 Lex 和 Yacc 同类工具构建 DSL 编译器的过程。是我和团队成员在伴鱼的质量工程小组的一小部分工作。&lt;/p&gt;
&lt;h3 id=&quot;背景&quot;&gt;背景&lt;/h3&gt;
&lt;p&gt;报警平台是伴鱼内部各端、应用、基础设施等&lt;strong&gt;服务异常状态信息的集散中心&lt;/strong&gt;。整体流程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/blog/2020/05/10/The-Evolution-of-Alertmanager-Matcher-in-Palfish/alertmanager-process.jpg&quot; height=&quot;150px&quot;&gt;&lt;/p&gt;
&lt;p&gt;信息源将信息投递给报警平台，后者将这些信息最终通过邮件、即时消息、电话呼叫的形式&lt;strong&gt;路由&lt;/strong&gt;给理应关心它的人。总体而言，路由的需求可以分为以下几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;路由给服务的负责人及其团队&lt;/li&gt;
&lt;li&gt;路由给服务依赖方人员及其团队&lt;/li&gt;
&lt;li&gt;路由给所有值班人员所在的即时消息群&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了满足这样的需求，报警平台采用树状结构组织路由信息，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/blog/2020/05/10/The-Evolution-of-Alertmanager-Matcher-in-Palfish/route-tree.jpg&quot; height=&quot;350px&quot;&gt;&lt;/p&gt;
&lt;p&gt;每个节点是一个路由节点，节点上可以挂载不同的规则，如抑制规则、通知规则；也可以存放不同的配置信息，如触发报警的阈值，以及相关负责人及其团队的联系方式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="system design" scheme="https://zhenghe-md.github.io/blog/categories/system-design/"/>
    
    
  </entry>
  
  <entry>
    <title>What&#39;s Really New with NewSQL (2016)</title>
    <link href="https://zhenghe-md.github.io/blog/2020/04/05/What-s-Really-New-with-NewSQL-2016/"/>
    <id>https://zhenghe-md.github.io/blog/2020/04/05/What-s-Really-New-with-NewSQL-2016/</id>
    <published>2020-04-05T20:39:47.000Z</published>
    <updated>2021-10-06T14:41:42.326Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;在进入文章之前，应该先介绍两位重量级作者：&lt;a href=&quot;cs.cmu.edu/~pavlo/&quot;&gt;Andrew Pavlo&lt;/a&gt; 和 &lt;a href=&quot;https://451research.com/analyst-team/analyst/Matt+Aslett&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Matthew Aslett&lt;/a&gt;。Andrew 在 CMU 的计算机科学学院任教，主攻方向包括内存数据库、自动驾驶系统架构、事务处理系统和海量数据分析，他是 CMU Database Group 的核心成员，在 CMU 开设的两门课程 Database Systems (15-445/645) 和 Advanced Database System (15-721) 全是干货；Matthew 是 &lt;a href=&quot;https://451research.com/about-us/our-research/research-channels/data-ai-analytics&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;451 research: Data, AI &amp;amp; Analytics channel&lt;/a&gt; 的 VP，他在 2011 年的一篇 &lt;a href=&quot;http://cs.brown.edu/courses/cs227/archives/2012/papers/newsql/aslett-newsql.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;论文&lt;/a&gt; 中第一次用 &lt;strong&gt;NewSQL&lt;/strong&gt; 指代提供类似 NoSQL 高吞吐、高可用支持，同时仍然保持 ACID 特性的新一代数据库系统。&lt;/p&gt;
&lt;p&gt;相比于已经问世 40 多年的关系型数据库 (relational DBMS) ，我们不禁会问：&quot;&lt;strong&gt;新兴的 NewSQL 究竟是一种市场营销还是确有其创新之处&lt;/strong&gt;？&quot; 如果 NewSQL 确实能够在多方面达到更高的性能，那么下一个问题就是：&quot;&lt;strong&gt;它的性能是来自于硬件的升级还是其系统设计有着科学上的创新&lt;/strong&gt;？&quot;&lt;/p&gt;
&lt;p&gt;要回答这两个问题，我们先讨论数据库系统的历史以及 NewSQL 的诞生，再讨论 NewSQL 在数据库系统各个重要设计方面的细节。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：本文基本上会是原文的一个完整翻译，如果你愿意，大可直接点击文末链接翻看原文 ：）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;a-brief-history-of-dbmss&quot;&gt;A Brief History of DBMSS&lt;/h2&gt;
&lt;p&gt;世界上第一个数据库系统，IBM IMS (Information Management System) 诞生于 1966 年，它被用于存储土星五号 (Saturn V) 和阿波罗 (Apollo) 空间探索项目所需的零件和供应商信息。IMS 的主要贡献在于展示了 &quot;&lt;strong&gt;应用程序逻辑与数据操作逻辑应该分离&lt;/strong&gt;&quot; 的理念，应用程序开发者只需要关注数据的逻辑变化，而无需关心其具体实现。在 IMS 之后，出现了第一批关系型数据库，其主要代表就是 IBM 的 System R 系统以及加州大学的 INGRES，即 PostgreSQL 的前身。INGRES 迅速在其它大学的信息系统中流行起来，并于 70 年代末商业化。大约在相同的时期，Oracle 采用类似 System R 的设计，开发并发布其 DBMS 的第一个版本。在 80 年代初期又涌现了一批公司，它们也推出自己的商业化数据库产品，如 Sybase 和 Informix。在 System R 之后，IBM 在 1983 年发布了新的关系型数据库 DB2，后者复用了 System R 的部分代码，但二者至今未开源。&lt;/p&gt;
&lt;p&gt;从 80 年代末到 90 年代初，面向对象的语言开始流行，这也催生了一批面向对象的 DBMS 诞生，以期磨平数据库模型与语言之间的隔阂。然而由于没有类似 SQL 一样的标准接口，这些面向对象的 DBMS 始终没有在市场上被广泛接受，不过它们的一些设计理念逐渐被融合进关系型数据库，许多流行的关系型数据库都增加了对 Object、XML 和 JSON 数据的支持。除此之外，面向文档 (document-oriented) 的 NoSQL 数据库也或多或少是面向对象的 DBMS 的延伸。&lt;/p&gt;
&lt;p&gt;90 年代的一个大事件就是两个开源关系型数据库的发布，MySQL 和 PostgreSQL。MySQL 于 1995 年在瑞士诞生，主要基于 ISAM 的 mSQL 系统开发；PostgreSQL 于 1994 年启动，由两名伯克利的学生 fork Postgres 的源码二次开发，增加 SQL 查询语言的支持。&lt;/p&gt;
&lt;p&gt;从 2000 年后，互联网应用如雨后春笋般出现，这些应用对各种资源的要求都远超传统的软件服务。互联网应用需要支持大量用户的并发访问，且对可用性要求极高，最好永远在线。在实践中，数据库开始成为互联网应用的瓶颈。许多厂商尝试纵向扩容，提高单机硬件性能，但这种方式换来的提升十分有限，表现出明显的边际收益递减。而且纵向扩容通常很不平滑，将数据从一台机器移动到另一台机器需要长时间下线服务，这对于互联网用户来说无法接受。为了解决这个问题，一些公司定制化开发中间件 (middleware)，将数据分片到多个普通单机 DBMS 上：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./middleware.jpg&quot; width=&quot;600px&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="papers-we-love" scheme="https://zhenghe-md.github.io/blog/categories/papers-we-love/"/>
    
    
      <category term="distributed system" scheme="https://zhenghe-md.github.io/blog/tags/distributed-system/"/>
    
      <category term="database" scheme="https://zhenghe-md.github.io/blog/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>Distributed Locking</title>
    <link href="https://zhenghe-md.github.io/blog/2020/03/22/Distributed-Locking/"/>
    <id>https://zhenghe-md.github.io/blog/2020/03/22/Distributed-Locking/</id>
    <published>2020-03-22T14:26:51.000Z</published>
    <updated>2021-10-06T14:41:42.294Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;提到分布式锁，很多人也许会脱口而出 &quot;redis&quot;，可见利用 redis 实现分布式锁已被认为是最佳实践。这两天有个同事问我一个问题：“如果某个服务拿着分布式锁的时候，redis 实例挂了怎么办？重启以后锁丢了怎么办？利用主从可以吗？加 fsync 可以吗？”&lt;/p&gt;
&lt;p&gt;因此我决定深究这个话题。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;备注：本文中，因为信息源使用的术语不同，Correctness 与 Safety 分别翻译成正确性和安全性，实际上二者在分布式锁话题的范畴中意思相同。&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;efficiency-correctness&quot;&gt;Efficiency &amp;amp; Correctness&lt;/h1&gt;
&lt;p&gt;如果想让单机/实例上的多个线程去执行同一组任务，为了避免任务被重复执行，使用本地环境提供的 Lock 原语即可实现；但如果想让单机/实例上，或多机/实例上的多个进程去抢同一组任务，就需要分布式锁。总体来说，对分布式锁的要求可以从两个角度来考虑：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;效率 (Efficiency)：为了避免一个任务被执行多次，每个执行方在任务启动时先抢锁，在绝大多数情况下能避免重复工作。即便在极其偶然的情况下，分布式锁服务故障导致同一时刻有两个执行方抢到锁，使得某个任务被执行两次，总体看来依然无伤大雅。&lt;/li&gt;
&lt;li&gt;正确性 (Correctness)：多个任务执行方仅能有一方成功获取锁，进而执行任务，否则系统的状态会被破坏。比如任务执行两次可能破坏文件结构、丢失数据、产生不一致数据或其它不可逆的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以效率和正确性为横轴和纵轴，得到一个直角坐标系，那么任何一个 (分布式) 锁解决方案就可以认为是这个坐标系中的一个点：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/blog/2020/03/22/Distributed-Locking/correctness-and-efficiency.jpg&quot; width=&quot;680px&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;solutions&quot;&gt;Solutions&lt;/h1&gt;
&lt;p&gt;在进入分布式锁解决方案之前，必须要明确：&lt;strong&gt;分布式锁只是某个特定业务需求解决方案的一部分&lt;/strong&gt;，业务功能的真正实现是&lt;strong&gt;业务服务&lt;/strong&gt;、&lt;strong&gt;分布式锁&lt;/strong&gt;、&lt;strong&gt;存储服务&lt;/strong&gt;以及&lt;strong&gt;其它有关各方&lt;/strong&gt;共同努力的结果。&lt;/p&gt;
    
    </summary>
    
    
      <category term="system design" scheme="https://zhenghe-md.github.io/blog/categories/system-design/"/>
    
    
      <category term="redis" scheme="https://zhenghe-md.github.io/blog/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Kafka: a Distributed Messaging System for Log Processing (2011)</title>
    <link href="https://zhenghe-md.github.io/blog/2020/03/15/Kafka-a-Distributed-Messaging-System-for-Log-Processing-2011/"/>
    <id>https://zhenghe-md.github.io/blog/2020/03/15/Kafka-a-Distributed-Messaging-System-for-Log-Processing-2011/</id>
    <published>2020-03-15T19:05:46.000Z</published>
    <updated>2021-10-06T14:41:42.302Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;论文引用量：744 (截止至 2020-03-15)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Kafka 是开发者耳熟能详的开源项目，它已经成为近年来互联网公司必不可少的基础组件。Kafka 得名于作家 Franz Kafka，大概是因为二者都比较擅长写日志 : )。它孵化于 LinkedIn 内部，在 2011 年被捐赠给 Apache 基金会，2012 年末正式从 Apache Incubator 中毕业。本文于 2011 年发表于 NetDB workshop，如今原文的三位作者，Jay Kreps、Neha Narkhede 以及 Jun Rao 一同离开 LinkedIn，创立 &lt;a href=&quot;https://www.confluent.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Confluent.io&lt;/a&gt;，提供基于 Kafka 的企业级 Event Streaming Platform 服务。&lt;/p&gt;
&lt;p&gt;除了翻译论文原文的核心内容之外，本文也会补充一些论文发表当时还未问世的话题，如 replication，exactly-once delivery 等。&lt;/p&gt;
&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;在规模较大的互联网公司中，每天都会产生大量的日志数据，如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户事件：登录、访问、点击、分享、评论、搜索&lt;/li&gt;
&lt;li&gt;性能指标：时延、错误、QPS&lt;/li&gt;
&lt;li&gt;机器指标：CPU、Memory、Network、Disk Utilication&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些日志数据常常被用于离线分析，帮助公司了解用户、产品，帮助开发者了解系统、服务。在初期，每当 LinkedIn 内部有服务需要使用这些日志数据时，研发人员就需要写新的数据传输脚本或在线传输逻辑，久而久之，内部服务的拓扑图就出现了类似完全图的形状：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/blog/2020/03/15/Kafka-a-Distributed-Messaging-System-for-Log-Processing-2011/all-to-all-topology.jpg&quot; width=&quot;600px&quot;&gt;&lt;/p&gt;
&lt;p&gt;这种拓扑图对分布式系统很不友好，不仅可能造成网络资源浪费，维护成本也极高。有 DRY 精神的工程师肯定无法忍受这样的架构，这时就需要有一个服务能将日志数据的消费和生产隔离：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/blog/2020/03/15/Kafka-a-Distributed-Messaging-System-for-Log-Processing-2011/pub-sub-topology.jpg&quot; width=&quot;600px&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="papers-we-love" scheme="https://zhenghe-md.github.io/blog/categories/papers-we-love/"/>
    
    
      <category term="kafka" scheme="https://zhenghe-md.github.io/blog/tags/kafka/"/>
    
      <category term="mq" scheme="https://zhenghe-md.github.io/blog/tags/mq/"/>
    
  </entry>
  
  <entry>
    <title>Scaling Memcache at Facebook (2013)</title>
    <link href="https://zhenghe-md.github.io/blog/2020/03/08/Scaling-Memcache-at-Facebook-2013/"/>
    <id>https://zhenghe-md.github.io/blog/2020/03/08/Scaling-Memcache-at-Facebook-2013/</id>
    <published>2020-03-08T16:40:55.000Z</published>
    <updated>2021-10-06T14:41:42.310Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍 FB 基于 memcached 构建统一缓存层的最佳实践。全文递进式地讲述 &lt;strong&gt;单集群 (Single Front-end Cluster)&lt;/strong&gt;、&lt;strong&gt;多集群 (Multiple Front-end Clusters)&lt;/strong&gt;、&lt;strong&gt;多区域 (Multiple Regions)&lt;/strong&gt; 环境下遇到的问题和相应的解决方案。尽管整个解决方案以 memcached 为基本单元，但我们可以任意地将 memcached 替换成 redis、boltDB、levelDB 等其它服务作为缓存单元。&lt;/p&gt;
&lt;p&gt;在下文中，需要注意两个词语的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;memcached：指 memcached 源码或运行时，即单机版&lt;/li&gt;
&lt;li&gt;memcache：指基于 memcached 构建的分布式缓存系统，即分布式版&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;background&quot;&gt;Background&lt;/h1&gt;
&lt;p&gt;与大部分互联网公司的读写流量特点类似，FB 的整体业务呈现出明显读多写少的特点，其读请求量比写请求量高出若 &lt;strong&gt;2&lt;/strong&gt; 个数量级 (数据来自于 &lt;a href=&quot;https://www.usenix.org/sites/default/files/conference/protected-files/nishtala_nsdi13_slides.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;slides&lt;/a&gt;)，因此增加缓存层可以显著提高业务稳定性，保护 DB。&lt;/p&gt;
&lt;h2 id=&quot;pre-memcache&quot;&gt;Pre-memcache&lt;/h2&gt;
&lt;p&gt;在使用缓存层之前，FB 的 Web Server 直接访问数据库，通过 &lt;strong&gt;数据分片&lt;/strong&gt; 和 &lt;strong&gt;一主多从&lt;/strong&gt; 的方式来扛住读写流量：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/blog/2020/03/08/Scaling-Memcache-at-Facebook-2013/pre-memcache.jpg&quot; width=&quot;500px&quot;&gt;&lt;/p&gt;
&lt;p&gt;但随着用户数数量飙升，单纯靠数据库来抗压成本高，效率低。&lt;/p&gt;
&lt;h2 id=&quot;design-requirements&quot;&gt;Design Requirements&lt;/h2&gt;
    
    </summary>
    
    
      <category term="papers-we-love" scheme="https://zhenghe-md.github.io/blog/categories/papers-we-love/"/>
    
    
      <category term="distributed system" scheme="https://zhenghe-md.github.io/blog/tags/distributed-system/"/>
    
      <category term="kv" scheme="https://zhenghe-md.github.io/blog/tags/kv/"/>
    
      <category term="cache" scheme="https://zhenghe-md.github.io/blog/tags/cache/"/>
    
  </entry>
  
  <entry>
    <title>The Evolution of Prometheus Storage Layer</title>
    <link href="https://zhenghe-md.github.io/blog/2020/02/27/The-Evolution-of-Prometheus-Storage-Layer/"/>
    <id>https://zhenghe-md.github.io/blog/2020/02/27/The-Evolution-of-Prometheus-Storage-Layer/</id>
    <published>2020-02-27T09:50:01.000Z</published>
    <updated>2021-10-06T14:41:42.318Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Prometheus 是当下最流行的监控平台之一，它的主要职责是从各个目标节点中采集监控数据，后持久化到本地的时序数据库中，并向外部提供便捷的查询接口。本文尝试探讨 Prometheus 存储层的演进过程，信息源主要来自于 Prometheus 团队在历届 PromConf 上的分享。&lt;/p&gt;
&lt;p&gt;时序数据库是 Promtheus 监控平台的一部分，在了解其存储层的演化过程之前，我们需要先了解时序数据库及其要解决的根本问题。&lt;/p&gt;
&lt;h1 id=&quot;tsdb&quot;&gt;TSDB&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;时序数据库 (Time Series Database, TSDB)&lt;/strong&gt; 是数据库大家庭中的一员，专门存储随时间变化的数据，如股票价格、传感器数据、机器状态监控等等。&lt;strong&gt;时序 (Time Series)&lt;/strong&gt; 指的是某个变量随时间变化的所有历史，而&lt;strong&gt;样本 (Sample)&lt;/strong&gt; 指的是历史中该变量的瞬时值：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/blog/2020/02/27/The-Evolution-of-Prometheus-Storage-Layer/ts-sample.jpg&quot; width=&quot;500px&quot;&gt;&lt;/p&gt;
&lt;p&gt;每个样本由&lt;strong&gt;时序标识&lt;/strong&gt;、&lt;strong&gt;时间戳&lt;/strong&gt;和&lt;strong&gt;数值&lt;/strong&gt; 3 部分构成，其所属的时序就由一系列样本构成。由于时间是连续的，我们不可能、也没有必要记录时序在每个时刻的数值，因此&lt;strong&gt;采样间隔&lt;/strong&gt; (Interval) 也是时序的重要组成部分。采样间隔越小、样本总量越大、捕获细节越多；采样间隔越大、样本总量越小、遗漏细节越多。以服务器机器监控为例，通常采样间隔为 15 秒。&lt;/p&gt;
&lt;p&gt;数据的高效查询离不开索引，对于时序数据而言，唯一的、天然的索引就是时间 (戳)。因此通常时序数据库的存储层相比于关系型数据库要简单得多。仔细思考，你可能会发现时序数据在某种程度上就是键值数据的一个子集，因此键值数据库天然地可以作为时序数据的载体。通常一个时序数据库能容纳百万量级以上的时序数据，要从其中搜索到其中少量的几个时序也非易事，因此对时序本身建立高效的索引也很重要。&lt;/p&gt;
&lt;h1 id=&quot;the-fundamental-problem-of-tsdbs&quot;&gt;The Fundamental Problem of TSDBs&lt;/h1&gt;
&lt;p&gt;TSDB 要解决的基本问题，可以概括为下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/blog/2020/02/27/The-Evolution-of-Prometheus-Storage-Layer/tsdb-fundamental-problem.jpg&quot; width=&quot;500px&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="system design" scheme="https://zhenghe-md.github.io/blog/categories/system-design/"/>
    
    
      <category term="tsdb" scheme="https://zhenghe-md.github.io/blog/tags/tsdb/"/>
    
  </entry>
  
</feed>
