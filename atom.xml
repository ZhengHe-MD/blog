<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZhengHe</title>
  <icon>https://zhenghe-md.github.io/blog/icon.png</icon>
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://zhenghe-md.github.io/blog/"/>
  <updated>2022-02-20T12:41:30.765Z</updated>
  <id>https://zhenghe-md.github.io/blog/</id>
  
  <author>
    <name>ZhengHe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从头开始实现 RNN</title>
    <link href="https://zhenghe-md.github.io/blog/2022/02/20/rnn/"/>
    <id>https://zhenghe-md.github.io/blog/2022/02/20/rnn/</id>
    <published>2022-02-20T15:03:20.000Z</published>
    <updated>2022-02-20T12:41:30.765Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;What I cannot create, I do not understand. -- Richard Feynman&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Andrej Karpathy 在 2015 年发表了题为 &lt;a href=&quot;https://karpathy.github.io/2015/05/21/rnn-effectiveness/&quot;&gt;The Unreasonable Effectiveness of Recurrent Neural Networks&lt;/a&gt; 的博客，并配套开源其中实验所用的&lt;a href=&quot;https://github.com/karpathy/char-rnn&quot;&gt;char-rnn 代码仓库&lt;/a&gt;，以及用 numpy 手写的 &lt;a href=&quot;https://gist.github.com/karpathy/d4dee566867f8291f086&quot;&gt;gist: min-char-rnn&lt;/a&gt;，阅读过后受益良多。于是这两天花了些时间：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;逐行理解 min-char-rnn&lt;/li&gt;
&lt;li&gt;基于理解和原脚本实现了 2-layer 和 n-layer 的 RNN&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;整个探索过程充满了趣味和挑战，尤其是对于一位主营服务端开发的工程师，因此特意将这个过程记录下来。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>让翻译触手可及</title>
    <link href="https://zhenghe-md.github.io/blog/2022/02/07/quick-translate/"/>
    <id>https://zhenghe-md.github.io/blog/2022/02/07/quick-translate/</id>
    <published>2022-02-07T20:44:52.000Z</published>
    <updated>2022-02-20T12:41:30.765Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;因为平时需要阅读大量的英文资料，翻译对我来说是一个高频需求，但我一直没能找到一个足够趁手的工具。对于一个理想的翻译工具，我有三点期望：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;翻译准确：翻译的结果与原文贴合不显得尴尬&lt;/li&gt;
&lt;li&gt;触发简单：复制到剪贴板后快速触发翻译指令&lt;/li&gt;
&lt;li&gt;响应迅速：发起翻译请求到获得结果小于一秒&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>推荐一个系列 「Let&#39;s Build A Simple Interpreter」</title>
    <link href="https://zhenghe-md.github.io/blog/2022/01/03/On-Let-s-Build-A-Simple-Interpreter/"/>
    <id>https://zhenghe-md.github.io/blog/2022/01/03/On-Let-s-Build-A-Simple-Interpreter/</id>
    <published>2022-01-03T19:43:37.000Z</published>
    <updated>2022-02-20T12:41:30.721Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;前阵子无意中发现了一个系列教程：「&lt;a href=&quot;https://github.com/rspivak/lsbasi&quot;&gt;Let&#39;s Build A Simple Interpreter&lt;/a&gt; 」，简称 lsbasi。本来只是随便翻翻，但刚看完 Part-1 就发现作者 &lt;a href=&quot;https://ruslanspivak.com/pages/about/&quot;&gt;Ruslan Spivak&lt;/a&gt; 不仅是一个出色的软件工程师，文笔也相当不错，更难得的是他对学习这件事本身有着比较深入的理解。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="笨学指南" scheme="https://zhenghe-md.github.io/blog/tags/%E7%AC%A8%E5%AD%A6%E6%8C%87%E5%8D%97/"/>
    
      <category term="tutorial" scheme="https://zhenghe-md.github.io/blog/tags/tutorial/"/>
    
  </entry>
  
  <entry>
    <title>推荐一本书「Make It Stick：The Science of Successful Learning」</title>
    <link href="https://zhenghe-md.github.io/blog/2021/11/28/Make-It-Stick-Digest/"/>
    <id>https://zhenghe-md.github.io/blog/2021/11/28/Make-It-Stick-Digest/</id>
    <published>2021-11-28T20:54:58.000Z</published>
    <updated>2022-02-20T12:41:30.721Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;/blog/2021/10/06/Announcing-the-start-of-project-LTTHW/&quot;&gt;启动「笨学指南」项目&lt;/a&gt;后，我和许多朋友聊了我想做的事，他们中的一位——「肚子」，向我推荐了 &lt;a href=&quot;https://www.goodreads.com/book/show/18770267-make-it-stick&quot;&gt;Make It Stick: The Science of Successful Learning&lt;/a&gt; 这本书 (以下简称 MIS)。MIS 从认知心理学的角度出发分析了人的认知特点，以及如何利用它们来提高学习效率。MIS 让我意识到：之前关于「笨学指南」的想法主要还是构建在一种冲动之上，没有理论支撑，而这本书正好作为这方面的补充。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="笨学指南" scheme="https://zhenghe-md.github.io/blog/tags/%E7%AC%A8%E5%AD%A6%E6%8C%87%E5%8D%97/"/>
    
  </entry>
  
  <entry>
    <title>启动「笨学指南」项目</title>
    <link href="https://zhenghe-md.github.io/blog/2021/10/06/Announcing-the-start-of-project-LTTHW/"/>
    <id>https://zhenghe-md.github.io/blog/2021/10/06/Announcing-the-start-of-project-LTTHW/</id>
    <published>2021-10-06T19:55:53.000Z</published>
    <updated>2022-02-20T12:41:30.697Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;国庆前夕，我利用业余时间过了一遍 YC 的 &lt;a href=&quot;https://www.youtube.com/playlist?list=PLQ-uHSnFig5OMuEYI4rnNz08BIHxhxdHG&quot;&gt;Startup School 2019&lt;/a&gt; 的系列课程，甚至煞有介事地写了一份 YC application，这样便算是完成了所有准备工作。而国庆期间，我哪也没去，希望能集中精力完成「笨学指南」的原型，并在国庆后利用闲暇时间 (目前有全职工作) 执行下一步计划。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="笨学指南" scheme="https://zhenghe-md.github.io/blog/tags/%E7%AC%A8%E5%AD%A6%E6%8C%87%E5%8D%97/"/>
    
  </entry>
  
  <entry>
    <title>对话系统调研报告</title>
    <link href="https://zhenghe-md.github.io/blog/2021/07/24/dialogue-system-research/"/>
    <id>https://zhenghe-md.github.io/blog/2021/07/24/dialogue-system-research/</id>
    <published>2021-07-24T09:37:30.000Z</published>
    <updated>2022-02-20T12:41:30.757Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;今年 6 月底，由于工作需要，花了两周时间调研对话系统，并在公司内部做了一次调研报告。本文意在将此报告整理成文字版，算是对这段时间付出的一个交代。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="system design" scheme="https://zhenghe-md.github.io/blog/tags/system-design/"/>
    
  </entry>
  
  <entry>
    <title>「Born a Crime」读后感</title>
    <link href="https://zhenghe-md.github.io/blog/2021/05/23/born-a-crime/"/>
    <id>https://zhenghe-md.github.io/blog/2021/05/23/born-a-crime/</id>
    <published>2021-05-23T09:04:37.000Z</published>
    <updated>2022-02-20T12:41:30.737Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;因为之前在 Youtube 和 B 站上零星地看了一些 Trevor Noah 的 stand-up 和 Daily Show，加上最近在 Palfish App 上与来自南非的老师学英语，我在大约四月中旬决定读一读「Born a Crime」这本书，书的内容本来并不多，但个人时间安排原因使得这个过程变得很长，直到昨天终于读完。&lt;/p&gt;
    
    </summary>
    
    
      <category term="readings" scheme="https://zhenghe-md.github.io/blog/categories/readings/"/>
    
    
  </entry>
  
  <entry>
    <title>代码搜索引擎：基础篇</title>
    <link href="https://zhenghe-md.github.io/blog/2021/05/09/search-engine-for-codes-fundamentals/"/>
    <id>https://zhenghe-md.github.io/blog/2021/05/09/search-engine-for-codes-fundamentals/</id>
    <published>2021-05-09T10:19:17.000Z</published>
    <updated>2022-02-20T12:41:30.769Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&quot;Google 内部曾对工程师做一次 &lt;a href=&quot;https://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/43835.pdf&quot;&gt;调研&lt;/a&gt;，发现平均每位工程师每天会进行 5.3 次代码搜索会话 (session)，执行 12 个代码搜索请求；在 Github/Gitlab 等仓库托管服务中，搜索是工程师最常用的功能之一。&quot;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="system design" scheme="https://zhenghe-md.github.io/blog/tags/system-design/"/>
    
  </entry>
  
  <entry>
    <title>调用链追踪系统在伴鱼：实践篇</title>
    <link href="https://zhenghe-md.github.io/blog/2021/03/04/implementing-tail-based-sampling/"/>
    <id>https://zhenghe-md.github.io/blog/2021/03/04/implementing-tail-based-sampling/</id>
    <published>2021-03-04T17:03:51.000Z</published>
    <updated>2022-02-20T12:41:30.761Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;此文同时发表在&lt;a href=&quot;https://tech.ipalfish.com/blog/2021/03/04/implementing-tail-based-sampling/&quot;&gt;伴鱼技术博客&lt;/a&gt;上&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 &lt;a href=&quot;https://zhenghe-md.github.io/blog/2020/12/20/design-dimensions-of-tracing-systems/&quot;&gt;理论篇&lt;/a&gt; 中，我们介绍了伴鱼在调用链追踪领域的调研工作，本篇继续介绍伴鱼的调用链追踪实践。在正式介绍前，简单交代一下背景：2015 年，在伴鱼服务端起步之时，技术团队就做出统一使用 Go 语言的决定。这个决定的影响主要体现在：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;内部基础设施无需做跨语言支持&lt;/li&gt;
&lt;li&gt;技术选型会有轻微的语言倾向&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="system design" scheme="https://zhenghe-md.github.io/blog/categories/system-design/"/>
    
    
  </entry>
  
  <entry>
    <title>调用链追踪系统的设计维度</title>
    <link href="https://zhenghe-md.github.io/blog/2020/12/20/design-dimensions-of-tracing-systems/"/>
    <id>https://zhenghe-md.github.io/blog/2020/12/20/design-dimensions-of-tracing-systems/</id>
    <published>2020-12-20T23:03:14.000Z</published>
    <updated>2022-02-20T12:41:30.737Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;本文将调用链追踪系统的设计维度归结于以下 5 个：调用链数据模型、元数据结构、因果关系、采样策略以及数据可视化。我们可以把这 5 个维度当作一个分析框架，用它帮助我们在理论上解构市面上任意一个调用链追踪系统，在实践中根据使用场景进行技术选型和系统设计。如果你对调研相关系统很感兴趣，也欢迎参与到 &lt;a href=&quot;https://github.com/ZhengHe-MD/database-of-tracing-systems&quot;&gt;Database of Tracing Systems&lt;/a&gt; 项目中，一起调研市面上的项目，建立起调用链追踪系统的数据库。&lt;/p&gt;
    
    </summary>
    
    
      <category term="system design" scheme="https://zhenghe-md.github.io/blog/categories/system-design/"/>
    
    
      <category term="distributed tracing" scheme="https://zhenghe-md.github.io/blog/tags/distributed-tracing/"/>
    
      <category term="distributed system" scheme="https://zhenghe-md.github.io/blog/tags/distributed-system/"/>
    
  </entry>
  
  <entry>
    <title>So, you want to trace your distributed system? Key design insights from years of practical experience (2014)</title>
    <link href="https://zhenghe-md.github.io/blog/2020/11/29/so-you-want-to-trace-your-distributed-system-key-design-insights-from-years-of-practical-experience/"/>
    <id>https://zhenghe-md.github.io/blog/2020/11/29/so-you-want-to-trace-your-distributed-system-key-design-insights-from-years-of-practical-experience/</id>
    <published>2020-11-29T21:28:32.000Z</published>
    <updated>2022-02-20T12:41:30.773Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍一篇关于调用链追踪系统设计的论文。行文会尊从原论文的结构，但不是逐字翻译，以意译和加入个人理解的转述为主。&lt;/p&gt;

&lt;h1 id=&quot;introduction&quot;&gt;1. Introduction&lt;/h1&gt;
&lt;p&gt;如果把公司内部所有 IT 系统看作一个巨型分布式系统，通常其规模庞大、结构复杂，且拥有多层依赖和抽象，每层单拎出来也同样是个分布式系统。以 Google 的业务服务为例，如搜索、广告，会构建于内部基础服务之上，如 Bigtable；而 BigTable 又构建于 Google File System (GFS) 和 Chubby 之上。即便是业务服务本身，也可能存在多层 (multiple tiers) 结构，其中每层同样支持横向扩展。从巨石应用走向微服务，我们在组织架构和服务架构上都变得高效，但其代价就是下降的系统可观测性 (observability)。一个很现实的问题就是：几乎不存在一位工程师能够了解系统全貌，那么问题排查也将变得困难。从单机走向分布式，只关心单个进程、单台机器的性能指标已经远远不够，我们需要将监控的重心从以机器为中心 (machine-centric) 转向以流程为中心 (workflow-centric)，后者的核心方法便是调用链追踪系统。分布式系统的终极理想可以描述为：在获得横向扩展性的同时不暴露自己分布式的本质，即向外提供与单机系统相同的体验。调用链追踪系统概莫能外。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;按：原文将请求处理过程称为 workflow，下文会使用流程和请求来指代它；原文将以流程为中心的观测方法统称为 end-to-end tracing，由于现在分布式系统几乎是所有讨论的默认假设，本文将不再强调 end-to-end，将其直接译为调用链追踪。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;尽管大家对调用链追踪的兴趣浓厚，但关于如何设计一个调用链追踪系统，市面上、社区中提供的信息十分有限。更令人担忧的是，现存的文献和实践都将调用链追踪当作多种场景的万能解决方案 (one-size-fits-all)，然而我们以及 Dapper 的实践经验证明事实并非如此。因此在提出你的解决方案之前，最好明确你想要解决的问题是什么。&lt;/p&gt;
&lt;p&gt;调用链追踪的基本原理和概念十分通俗易懂：就是在系统中的各个节点 (组件) 上埋点，当请求经过时将节点信息 (trace point) 上报，最后汇总信息重建调用链。我们从经验中总结了调用链追踪系统的 4 个设计维度，通过组合这些设计维度的选择就能得到不同应用场景的解决方案：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;which causal relationships should be preserved: 保留什么样的因果关系？&lt;/li&gt;
&lt;li&gt;how causal relationships are tracked: 如何追踪因果关系？&lt;/li&gt;
&lt;li&gt;how to reduce overhead by sampling: 如何通过采样降低成本？&lt;/li&gt;
&lt;li&gt;how end-to-end traces should be visualized: 如何将追踪的结果可视化？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果对这 4 个设计维度以及它们之间的权衡关系没有足够的理解，设计一个调用链追踪系统将可能让实现与场景脱节。事实上，由于这些维度之前并未被实践者或研究者提出和充分理解，许多调用链追踪系统的实现并未能充分达成其设计理想。&lt;/p&gt;
&lt;h1 id=&quot;backgroud&quot;&gt;2. Backgroud&lt;/h1&gt;
&lt;p&gt;本节主要陈述一些调用链追踪系统的背景信息，包括核心应用场景、解决方案分类以及本文所推崇的架构方案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="papers-we-love" scheme="https://zhenghe-md.github.io/blog/categories/papers-we-love/"/>
    
    
      <category term="distributed tracing" scheme="https://zhenghe-md.github.io/blog/tags/distributed-tracing/"/>
    
      <category term="distributed system" scheme="https://zhenghe-md.github.io/blog/tags/distributed-system/"/>
    
      <category term="system design" scheme="https://zhenghe-md.github.io/blog/tags/system-design/"/>
    
  </entry>
  
  <entry>
    <title>Go Error Handling 方案调研</title>
    <link href="https://zhenghe-md.github.io/blog/2020/10/05/Go-Error-Handling-Research/"/>
    <id>https://zhenghe-md.github.io/blog/2020/10/05/Go-Error-Handling-Research/</id>
    <published>2020-10-05T16:20:00.000Z</published>
    <updated>2022-02-20T12:41:30.705Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;自从 2018 年底用 Go 搭建第一个项目以来，已经过去接近 2 年时间，我发现自己从未系统地思考过 Go 的 error handling 方案。最近在阅读 [1] 时，逐渐发现个人和团队都应该花更多的精力建立更加扎实的工程实践方法论，进一步提升交付项目质量。而本篇博客算是向这个方向迈出的第一步。&lt;/p&gt;
    
    </summary>
    
    
      <category term="engineering" scheme="https://zhenghe-md.github.io/blog/categories/engineering/"/>
    
    
      <category term="Go" scheme="https://zhenghe-md.github.io/blog/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Apache Arrow 小结</title>
    <link href="https://zhenghe-md.github.io/blog/2020/09/20/apache-arrow-summary/"/>
    <id>https://zhenghe-md.github.io/blog/2020/09/20/apache-arrow-summary/</id>
    <published>2020-09-20T21:14:48.000Z</published>
    <updated>2022-02-20T12:41:30.737Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;最近在阅读 TiDB 源码 util/chunk package 的过程中，看到了 Apache Arrow 这个项目 (下文简称 Arrow)：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Chunk stores multiple rows of data in Apache Arrow format.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// See https://arrow.apache.org/docs/format/Columnar.html#physical-memory-layout&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Values are appended in compact format and can be directly accessed without decoding.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// When the chunk is done processing, we can reuse the allocated memory by resetting it.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; Chunk &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &amp;#123; &lt;span class=&quot;comment&quot;&gt;/*...*/&lt;/span&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;心里自然而然会产生疑问：为什么要使用这个项目规定的数据存储格式？于是在阅读完 TiDB 相关源码和单测后，顺便搜寻并浏览一些有趣的资料 (见文末参考部分)，现在将这次调研的收获小结在这篇博客中。&lt;/p&gt;
    
    </summary>
    
    
      <category term="system design" scheme="https://zhenghe-md.github.io/blog/categories/system-design/"/>
    
    
      <category term="database" scheme="https://zhenghe-md.github.io/blog/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>The Anatomy of a Large-Scale Hypertextual Web Search Engine (1998)</title>
    <link href="https://zhenghe-md.github.io/blog/2020/07/21/the-anatomy-of-a-large-scale-hypertextual-web-search-engine-1998/"/>
    <id>https://zhenghe-md.github.io/blog/2020/07/21/the-anatomy-of-a-large-scale-hypertextual-web-search-engine-1998/</id>
    <published>2020-07-21T23:35:09.000Z</published>
    <updated>2022-02-20T12:41:30.781Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;最近因为工作的关系接触 ElasticSearch，发现搜索引擎也是计算机应用的一个有意思的分支。于是通过 Freiburg 的 Information Retrieval 公开课开始系统地了解信息检索这个领域，感觉收获颇丰。周末一时兴起，上 Google Research 找到了 Google 的开山之作，近距离地感受一下 19800+ 引用量、造就如今 Google 万亿市值的这篇文章。&lt;/p&gt;

&lt;p&gt;本文介绍会尽可能地忠于原文，但不是完全逐字逐句的翻译。&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;1. 简介&lt;/h2&gt;
&lt;p&gt;近年来，网络中的信息量和非专业的用户都在快速增长，为信息检索领域带来了新的挑战。从行为上看，人们更倾向于以门户网站，如 Yahoo，或搜索引擎为起点，利用网页间的链接来浏览所需信息。门户网站的索引来自于人工维护，聚合效果好、主观性高、维护成本高、改进速度慢，且通常不会覆盖小众话题。自动化的搜索引擎则相反，其它都满足，但聚合效果差，依赖于关键词匹配的检索方式返回的匹配项质量过低。一些广告商为了获取更多的流量，通过逆向工程来误导搜索引擎，使其结果靠前，进一步加剧问题的严重性。我们搭建了一个大型搜索引擎来当前系统的这些已知问题，它通过重度利用网页文本中的特殊结构来提供更高质量的检索结果。&lt;strong&gt;我们为这个系统取名为 Google，因为它是 googol (即 &lt;span class=&quot;math inline&quot;&gt;&lt;mjx-container class=&quot;MathJax&quot; jax=&quot;SVG&quot;&gt;&lt;svg style=&quot;vertical-align: -0.05ex&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;4.775ex&quot; height=&quot;2.005ex&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewBox=&quot;0 -864 2110.7 886&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;msup&quot;&gt;&lt;g data-mml-node=&quot;mn&quot;&gt;&lt;use xlink:href=&quot;#MJX-TEX-N-31&quot;/&gt;&lt;use xlink:href=&quot;#MJX-TEX-N-30&quot; transform=&quot;translate(500, 0)&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; transform=&quot;translate(1000, 393.1) scale(0.707)&quot; data-mjx-texclass=&quot;ORD&quot;&gt;&lt;g data-mml-node=&quot;mn&quot;&gt;&lt;use xlink:href=&quot;#MJX-TEX-N-31&quot;/&gt;&lt;use xlink:href=&quot;#MJX-TEX-N-30&quot; transform=&quot;translate(500, 0)&quot;/&gt;&lt;use xlink:href=&quot;#MJX-TEX-N-30&quot; transform=&quot;translate(1000, 0)&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/mjx-container&gt;&lt;/span&gt; ) 的常用拼写，后者的含义恰好与构建大型搜索引擎的目标体量相契合&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;网络搜索引擎的扩张1994---2000&quot;&gt;网络搜索引擎的扩张：1994 - 2000&lt;/h3&gt;
&lt;p&gt;为了跟上网络信息扩张的速度，搜索引擎技术也必须加速规模化。1994 年，World Wide Web Worm (WWWW)，第一代网络搜索引擎 (web search engine) 之一，对 11 万网页或文件建立了索引；到了 1997 年末，行业领先的网络搜索引擎建立索引的数量已达到 200 万 (WebCrawler)，甚至 1 亿 (Search Engine Watch)。可以预见这个数量在 2000 年将超过 10 亿。与此同时，网络上的搜索引擎处理的查询也在飞速增长。在 1994 年初，WWWW 大约每日需要处理 1500 次查询，到了 1997 年末，Altavista 已经声称自己每日处理的请求量达到 2 千万。同样可以预见，这个数量在 2000 年也将达到亿级。Google 的目标就是要提供相应规模、高质量的网络搜索服务。&lt;/p&gt;
&lt;h3 id=&quot;google-与网络一同扩张&quot;&gt;Google: 与网络一同扩张&lt;/h3&gt;
&lt;p&gt;即便是搭建一个满足当前规模的网络搜索引擎也需要面对许多挑战，如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高性能的网页抓取技术保证原始数据全而新&lt;/li&gt;
&lt;li&gt;充足的存储空间用以存放索引和网页本身 (如果需要的话)&lt;/li&gt;
&lt;li&gt;索引系统必须能够高效地处理百 G 级别的数据&lt;/li&gt;
&lt;li&gt;查询必须能被快速处理，QPS 过千&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="papers-we-love" scheme="https://zhenghe-md.github.io/blog/categories/papers-we-love/"/>
    
    
  </entry>
  
  <entry>
    <title>I ❤ Logs 小结</title>
    <link href="https://zhenghe-md.github.io/blog/2020/07/12/I-%E2%9D%A4-Logs-%E5%B0%8F%E7%BB%93/"/>
    <id>https://zhenghe-md.github.io/blog/2020/07/12/I-%E2%9D%A4-Logs-%E5%B0%8F%E7%BB%93/</id>
    <published>2020-07-12T18:06:15.000Z</published>
    <updated>2022-02-20T12:41:30.705Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;I ❤ Logs&lt;/em&gt; 出版于 2014 年，是一本很短小的书，100 页不到，利用这周的零散时间就看完了。作者 &lt;a href=&quot;https://www.linkedin.com/in/jaykreps/&quot;&gt;Jay Kreps&lt;/a&gt;，是前 LinkedIn 的 Principal Staff Engineer，也是 LinkedIn 许多著名开源项目的负责人及联合作者，如 Kafka、Voldemort 等。他是现任 &lt;a href=&quot;https://www.confluent.io/about/&quot;&gt;Confluent&lt;/a&gt; 的 CEO，主要工作在于围绕实时数据提供企业级服务支持。这本书算是 Jay Kreps 过去多年实践的思考结晶。&lt;/p&gt;
    
    </summary>
    
    
      <category term="books-we-love" scheme="https://zhenghe-md.github.io/blog/categories/books-we-love/"/>
    
    
  </entry>
  
  <entry>
    <title>Jaeger Walkthrough: jaeger-client-go</title>
    <link href="https://zhenghe-md.github.io/blog/2020/06/21/Jaeger-Walkthrough-jaeger-client-go/"/>
    <id>https://zhenghe-md.github.io/blog/2020/06/21/Jaeger-Walkthrough-jaeger-client-go/</id>
    <published>2020-06-21T22:28:35.000Z</published>
    <updated>2022-02-20T12:41:30.709Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Jaeger Walkthrough 系列文章之一，旨在深入理解 Jaeger 项目内部的实现细节。本文介绍的是 Jaeger 的 Go 客户端，&lt;a href=&quot;https://github.com/jaegertracing/jaeger-client-go/&quot;&gt;jaeger-client-go&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;jaeger-client-go 是 Jaeger 对 opentracing-go 标准接口的实现，主要解决的是两个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何在进程内部管理调用链追踪信息 (tracer, span)&lt;/li&gt;
&lt;li&gt;如何在进程间传递调用链追踪信息 (span context, propagation)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但在调用链追踪实践中，jaeger-client-go 仅仅解决上述两个问题还不够，它还需要考虑的问题包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何将数据上报到存储中心&lt;/li&gt;
&lt;li&gt;如何对数据抽样，支持不同的抽样策略&lt;/li&gt;
&lt;li&gt;需要收集哪些统计指标&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来，我们就着源码对这些问题一一分析。&lt;/p&gt;
&lt;h2 id=&quot;进程内调用链追踪信息管理&quot;&gt;进程内调用链追踪信息管理&lt;/h2&gt;
&lt;h3 id=&quot;tracer&quot;&gt;Tracer&lt;/h3&gt;
&lt;p&gt;Tracer 是 opentracing.Tracer 的实现，它负责与应用程序沟通，接收应用程序的请求，协调 jaeger-client-go 中各个模块完成相应工作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="open source project" scheme="https://zhenghe-md.github.io/blog/categories/open-source-project/"/>
    
    
  </entry>
  
  <entry>
    <title>Prometheus Alertmanager Walkthrough</title>
    <link href="https://zhenghe-md.github.io/blog/2020/06/13/Understanding-Prometheus-Alertmanager/"/>
    <id>https://zhenghe-md.github.io/blog/2020/06/13/Understanding-Prometheus-Alertmanager/</id>
    <published>2020-06-13T22:21:27.000Z</published>
    <updated>2022-02-20T12:41:30.733Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Alertmanager 是 Prometheus 提供的报警分发平台，它主要满足的是报警的路由、分组、抑制、去重等常见需求。&lt;/p&gt;
    
    </summary>
    
    
      <category term="open source project" scheme="https://zhenghe-md.github.io/blog/categories/open-source-project/"/>
    
    
  </entry>
  
  <entry>
    <title>The Most Beautiful Program Ever Written</title>
    <link href="https://zhenghe-md.github.io/blog/2020/06/07/The-Most-Beautiful-Program-Ever-Written/"/>
    <id>https://zhenghe-md.github.io/blog/2020/06/07/The-Most-Beautiful-Program-Ever-Written/</id>
    <published>2020-06-07T10:04:15.000Z</published>
    <updated>2022-02-20T12:41:30.733Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;本文来自于 2017 年 PWL NYC Meetup，作者的简介如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;William E. Byrd (&lt;span class=&quot;citation&quot; data-cites=&quot;webyrd&quot;&gt;@webyrd&lt;/span&gt;) is a Research Assistant Professor in the School of Computing at the University of Utah. He is co-author of &#39;The Reasoned Schemer&#39;, and is co-designer of the miniKanren relational programming language. He loves StarCraft (BW &amp;amp; SC2). Ask him about the scanning tunneling microscope (STM) he is building.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先假设你已经对 Scheme (Lisp 的一门方言) 的基本语法有一些了解。我们直奔主题，来看这个 &quot;The Most Beautiful Program Ever Written&quot; 究竟是什么程序。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="papers-we-love" scheme="https://zhenghe-md.github.io/blog/tags/papers-we-love/"/>
    
  </entry>
  
  <entry>
    <title>报警平台的匹配器演进</title>
    <link href="https://zhenghe-md.github.io/blog/2020/05/10/The-Evolution-of-Alertmanager-Matcher-in-Palfish/"/>
    <id>https://zhenghe-md.github.io/blog/2020/05/10/The-Evolution-of-Alertmanager-Matcher-in-Palfish/</id>
    <published>2020-05-10T00:00:00.000Z</published>
    <updated>2022-02-20T12:41:30.729Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;本文介绍伴鱼内部服务报警平台中匹配器模块的演进，及其利用 Lex 和 Yacc 同类工具构建 DSL 编译器的过程。是我和团队成员在伴鱼的质量工程小组的一小部分工作。&lt;/p&gt;

&lt;h3 id=&quot;背景&quot;&gt;背景&lt;/h3&gt;
&lt;p&gt;报警平台是伴鱼内部各端、应用、基础设施等&lt;strong&gt;服务异常状态信息的集散中心&lt;/strong&gt;。整体流程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/blog/2020/05/10/The-Evolution-of-Alertmanager-Matcher-in-Palfish/alertmanager-process.jpg&quot; height=&quot;150px&quot;&gt;&lt;/p&gt;
&lt;p&gt;信息源将信息投递给报警平台，后者将这些信息最终通过邮件、即时消息、电话呼叫的形式&lt;strong&gt;路由&lt;/strong&gt;给理应关心它的人。总体而言，路由的需求可以分为以下几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;路由给服务的负责人及其团队&lt;/li&gt;
&lt;li&gt;路由给服务依赖方人员及其团队&lt;/li&gt;
&lt;li&gt;路由给所有值班人员所在的即时消息群&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了满足这样的需求，报警平台采用树状结构组织路由信息，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/blog/2020/05/10/The-Evolution-of-Alertmanager-Matcher-in-Palfish/route-tree.jpg&quot; height=&quot;350px&quot;&gt;&lt;/p&gt;
&lt;p&gt;每个节点是一个路由节点，节点上可以挂载不同的规则，如抑制规则、通知规则；也可以存放不同的配置信息，如触发报警的阈值，以及相关负责人及其团队的联系方式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="system design" scheme="https://zhenghe-md.github.io/blog/categories/system-design/"/>
    
    
  </entry>
  
  <entry>
    <title>What&#39;s Really New with NewSQL (2016)</title>
    <link href="https://zhenghe-md.github.io/blog/2020/04/05/What-s-Really-New-with-NewSQL-2016/"/>
    <id>https://zhenghe-md.github.io/blog/2020/04/05/What-s-Really-New-with-NewSQL-2016/</id>
    <published>2020-04-05T20:39:47.000Z</published>
    <updated>2022-02-20T12:41:30.733Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;在进入文章之前，应该先介绍两位重量级作者：&lt;a href=&quot;cs.cmu.edu/~pavlo/&quot;&gt;Andrew Pavlo&lt;/a&gt; 和 &lt;a href=&quot;https://451research.com/analyst-team/analyst/Matt+Aslett&quot;&gt;Matthew Aslett&lt;/a&gt;。Andrew 在 CMU 的计算机科学学院任教，主攻方向包括内存数据库、自动驾驶系统架构、事务处理系统和海量数据分析，他是 CMU Database Group 的核心成员，在 CMU 开设的两门课程 Database Systems (15-445/645) 和 Advanced Database System (15-721) 全是干货；Matthew 是 &lt;a href=&quot;https://451research.com/about-us/our-research/research-channels/data-ai-analytics&quot;&gt;451 research: Data, AI &amp;amp; Analytics channel&lt;/a&gt; 的 VP，他在 2011 年的一篇 &lt;a href=&quot;http://cs.brown.edu/courses/cs227/archives/2012/papers/newsql/aslett-newsql.pdf&quot;&gt;论文&lt;/a&gt; 中第一次用 &lt;strong&gt;NewSQL&lt;/strong&gt; 指代提供类似 NoSQL 高吞吐、高可用支持，同时仍然保持 ACID 特性的新一代数据库系统。&lt;/p&gt;
    
    </summary>
    
    
      <category term="papers-we-love" scheme="https://zhenghe-md.github.io/blog/categories/papers-we-love/"/>
    
    
      <category term="distributed system" scheme="https://zhenghe-md.github.io/blog/tags/distributed-system/"/>
    
      <category term="database" scheme="https://zhenghe-md.github.io/blog/tags/database/"/>
    
  </entry>
  
</feed>
